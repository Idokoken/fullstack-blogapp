{"ast":null,"code":"/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport '../utils/boot.js';\nimport { wrap } from '../utils/wrap.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { root, isAncestor, isDescendant, get, translate, isPath, set, normalize } from '../utils/path.js';\n/* for notify, reflect */\n\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertyAccessors } from './property-accessors.js';\n/* for annotated effects */\n\nimport { TemplateStamp } from './template-stamp.js';\nimport { sanitizeDOMValue, legacyUndefined, orderedComputed, removeNestedTemplates, fastDomIf } from '../utils/settings.js'; // Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\n\nlet dedupeId = 0;\nconst NOOP = [];\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\n\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\nconst COMPUTE_INFO = '__computeInfo';\n/** @const {!RegExp} */\n\nconst capitalAttributeRegex = /[A-Z]/;\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\n\nlet DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\n\nlet DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\n\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  let effects = model[type];\n\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n\n    if (cloneArrays) {\n      for (let p in effects) {\n        let protoFx = effects[p]; // Perf optimization over Array.slice\n\n        let instFx = effects[p] = Array(protoFx.length);\n\n        for (let i = 0; i < protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n\n  return effects;\n} // -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\n\n\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    const id = dedupeId++;\n\n    for (let prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      let rootProperty = hasPaths ? root(prop) : prop;\n      let fxs = effects[rootProperty];\n\n      if (fxs) {\n        for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n\n    return ran;\n  }\n\n  return false;\n}\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\n\n\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? root(prop) : prop;\n  let fxs = effects[rootProperty];\n\n  if (fxs) {\n    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n\n  return ran;\n}\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\n\n\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath =\n    /** @type {string} */\n    trigger.name;\n    return triggerPath == path || !!(trigger.structured && isAncestor(triggerPath, path)) || !!(trigger.wildcard && isDescendant(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\n\n\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\n\n\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId++; // Try normal notify effects; if none, fall back to try path notification\n\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  } // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n\n\n  let host;\n\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\n\n\nfunction notifyPath(inst, path, props) {\n  let rootProperty = root(path);\n\n  if (rootProperty !== path) {\n    let eventName = camelToDashCase(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\n\n\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n\n  if (path) {\n    detail.path = path;\n  } // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n\n\n  wrap(\n  /** @type {!HTMLElement} */\n  inst).dispatchEvent(new CustomEvent(eventName, {\n    detail\n  }));\n}\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\n\n\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? root(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? get(inst, path) : inst.__data[property];\n\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\n\n\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail =\n  /** @type {Object} */\n  event.detail;\n  let fromPath = detail && detail.path;\n\n  if (fromPath) {\n    toPath = translate(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n\n  value = negate ? !value : value;\n\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\n\n\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, info.attrName, 'attribute',\n    /** @type {Node} */\n    inst);\n  }\n\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\n\n\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n\n  if (computeEffects) {\n    if (orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      const order = getComputedOrder(inst);\n      const queue = [];\n\n      for (let p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n\n      let info;\n\n      while (info = queue.shift()) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n\n      Object.assign(\n      /** @type {!Object} */\n      oldProps, inst.__dataOld);\n      Object.assign(\n      /** @type {!Object} */\n      changedProps, inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      let inputProps = changedProps;\n\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(\n        /** @type {!Object} */\n        oldProps, inst.__dataOld);\n        Object.assign(\n        /** @type {!Object} */\n        changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\n\n\nconst insertEffect = (info, queue, order) => {\n  let start = 0;\n  let end = queue.length - 1;\n  let idx = -1;\n\n  while (start <= end) {\n    const mid = start + end >> 1; // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n\n  if (idx < 0) {\n    idx = end + 1;\n  }\n\n  queue.splice(idx, 0, info);\n};\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\n\n\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\n  const rootProperty = hasPaths ? root(prop) : prop;\n  const fxs = computeEffects[rootProperty];\n\n  if (fxs) {\n    for (let i = 0; i < fxs.length; i++) {\n      const fx = fxs[i];\n\n      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\n\n\nfunction getComputedOrder(inst) {\n  let ordered = inst.constructor.__orderedComputedDeps;\n\n  if (!ordered) {\n    ordered = new Map();\n    const effects = inst[TYPES.COMPUTE];\n    let {\n      counts,\n      ready,\n      total\n    } = dependencyCounts(inst);\n    let curr;\n\n    while (curr = ready.shift()) {\n      ordered.set(curr, ordered.size);\n      const computedByCurr = effects[curr];\n\n      if (computedByCurr) {\n        computedByCurr.forEach(fx => {\n          // Note `methodInfo` is where the computed property name is stored\n          const computedProp = fx.info.methodInfo;\n          --total;\n\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n\n    if (total !== 0) {\n      const el =\n      /** @type {HTMLElement} */\n      inst;\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\n    }\n\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n\n  return ordered;\n}\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\n\n\nfunction dependencyCounts(inst) {\n  const infoForComputed = inst[COMPUTE_INFO];\n  const counts = {};\n  const computedDeps = inst[TYPES.COMPUTE];\n  const ready = [];\n  let total = 0; // Count dependencies for each computed property\n\n  for (let p in infoForComputed) {\n    const info = infoForComputed[p]; // Be sure to add the method name itself in case of \"dynamic functions\"\n\n    total += counts[p] = info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\n  } // Build list of ready properties (that aren't themselves computed)\n\n\n  for (let p in computedDeps) {\n    if (!infoForComputed[p]) {\n      ready.push(p);\n    }\n  }\n\n  return {\n    counts,\n    ready,\n    total\n  };\n}\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\n\n\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info); // Abort if method returns a no-op result\n\n  if (result === NOOP) {\n    return false;\n  }\n\n  let computedProp = info.methodInfo;\n\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\n\n\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n\n  if (links) {\n    let link;\n\n    for (let a in links) {\n      let b = links[a];\n\n      if (isDescendant(a, path)) {\n        link = translate(a, b, path);\n\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if (isDescendant(b, path)) {\n        link = translate(b, a, path);\n\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n} // -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\n\n\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let\n  /** Binding */\n  binding = {\n    kind,\n    target,\n    parts,\n    literal,\n    isCompound: parts.length !== 1\n  };\n  nodeInfo.bindings.push(binding); // Add listener info to binding metadata\n\n  if (shouldAddListener(binding)) {\n    let {\n      event,\n      negate\n    } = binding.parts[0];\n    binding.listenerEvent = event || camelToDashCase(target) + '-changed';\n    binding.listenerNegate = negate;\n  } // Add \"propagate\" property effects to templateInfo\n\n\n  let index = templateInfo.nodeInfoList.length;\n\n  for (let i = 0; i < binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\n\n\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = {\n        index,\n        binding,\n        part,\n        evaluator: constructor\n      };\n\n      for (let j = 0; j < dependencies.length; j++) {\n        let trigger = dependencies[j];\n\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info,\n          trigger\n        });\n      }\n    }\n  }\n}\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\n\n\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part; // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = translate(part.source, binding.target, path);\n\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths); // Propagate value to child\n    // Abort if value is a no-op result\n\n\n    if (value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n}\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\n\n\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\n  }\n\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute(\n    /** @type {Element} */\n    node, value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\n\n\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n\n  return value;\n}\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\n\n\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n}\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\n\n\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {\n    nodeList,\n    nodeInfoList\n  } = templateInfo;\n\n  if (nodeInfoList.length) {\n    for (let i = 0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n\n      if (bindings) {\n        for (let i = 0; i < bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      } // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n\n\n      node.__dataHost = inst;\n    }\n  }\n}\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\n\n\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    let parts = binding.parts; // Copy literals from parts into storage for this binding\n\n    let literals = new Array(parts.length);\n\n    for (let j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n\n    let target = binding.target;\n    storage[target] = literals; // Configure properties with their literal parts\n\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = wrap(node);\n      }\n\n      node[target] = binding.literal;\n    }\n  }\n}\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\n\n\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n} // -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\n\n\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n\n  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn,\n        info: info,\n        trigger: arg\n      });\n    }\n  }\n\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn,\n      info: info\n    });\n  }\n\n  return info;\n}\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\n\n\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n\n  if (fn) {\n    let args = inst._marshalArgs(info.args, property, props);\n\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nconst emptyArray = []; // Regular expressions used for binding\n\nconst IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\n\nfunction literalFromParts(parts) {\n  let s = '';\n\n  for (let i = 0; i < parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n\n  return s;\n}\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\n\n\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n\n  if (m) {\n    let methodName = m[1];\n    let sig = {\n      methodName,\n      static: true,\n      args: emptyArray\n    };\n\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n\n  return null;\n}\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\n\n\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    let arg = parseArg(rawArg);\n\n    if (!arg.literal) {\n      sig.static = false;\n    }\n\n    return arg;\n  }, this);\n  return sig;\n}\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\n\n\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim() // replace comma entity with comma\n  .replace(/&comma;/g, ',') // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '\\$1'); // basic argument descriptor\n\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  }; // detect literal value (must be String or Number)\n\n  let fc = arg[0];\n\n  if (fc === '-') {\n    fc = arg[1];\n  }\n\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  } // if not literal, look for structured path\n\n\n  if (!a.literal) {\n    a.rootProperty = root(arg); // detect structured path (has dots)\n\n    a.structured = isPath(arg);\n\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n\n  return a;\n}\n\nfunction getArgValue(data, props, path) {\n  let value = get(data, path); // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n\n  if (value === undefined) {\n    value = props[path];\n  }\n\n  return value;\n} // data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\n\n\nfunction notifySplices(inst, array, path, splices) {\n  const splicesData = {\n    indexSplices: splices\n  }; // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length); // Clear splice data only when it's stored on the array.\n\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\n\n\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\n\n\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\n\n\nexport const PropertyEffects = dedupingMixin(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n\n  class PropertyEffects extends propertyEffectsBase {\n    constructor() {\n      super();\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n\n      this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n\n      this.__dataClientsReady;\n      /** @type {Array} */\n\n      this.__dataPendingClients;\n      /** @type {Object} */\n\n      this.__dataToNotify;\n      /** @type {Object} */\n\n      this.__dataLinkedPaths;\n      /** @type {boolean} */\n\n      this.__dataHasPaths;\n      /** @type {Object} */\n\n      this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n\n      this.__dataHost;\n      /** @type {!Object} */\n\n      this.__dataTemp;\n      /** @type {boolean} */\n\n      this.__dataClientsInitialized;\n      /** @type {!Object} */\n\n      this.__data;\n      /** @type {!Object|null} */\n\n      this.__dataPending;\n      /** @type {!Object} */\n\n      this.__dataOld;\n      /** @type {Object} */\n\n      this.__computeEffects;\n      /** @type {Object} */\n\n      this.__computeInfo;\n      /** @type {Object} */\n\n      this.__reflectEffects;\n      /** @type {Object} */\n\n      this.__notifyEffects;\n      /** @type {Object} */\n\n      this.__propagateEffects;\n      /** @type {Object} */\n\n      this.__observeEffects;\n      /** @type {Object} */\n\n      this.__readOnly;\n      /** @type {!TemplateInfo} */\n\n      this.__templateInfo;\n      /** @type {boolean} */\n\n      this._overrideLegacyUndefined;\n    }\n\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    }\n    /**\n     * @override\n     * @return {void}\n     */\n\n\n    _initializeProperties() {\n      super._initializeProperties();\n\n      this._registerHost();\n\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false; // May be set on instance prior to upgrade\n\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    }\n\n    _registerHost() {\n      if (hostStack.length) {\n        let host = hostStack[hostStack.length - 1];\n\n        host._enqueueClient(this); // This ensures even non-bound elements have a host set, as\n        // long as they upgrade synchronously\n\n\n        this.__dataHost = host;\n      }\n    }\n    /**\n     * Overrides `PropertyAccessors` implementation to provide a\n     * more efficient implementation of initializing properties from\n     * the prototype on the instance.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the prototype\n     * @return {void}\n     */\n\n\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    }\n    /**\n     * Overrides `PropertyAccessors` implementation to avoid setting\n     * `_setProperty`'s `shouldNotify: true`.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the instance\n     * @return {void}\n     */\n\n\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    } // Prototype setup ----------------------------------------\n\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n\n\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY); // effects are accumulated into arrays per property based on type\n\n\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n\n      effects.push(effect);\n    }\n    /**\n     * Removes the given property effect.\n     *\n     * @override\n     * @param {string} property Property the effect was associated with\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object to remove\n     * @return {void}\n     */\n\n\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      let idx = effects.indexOf(effect);\n\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    }\n    /**\n     * Returns whether the current prototype/instance has a property effect\n     * of a certain type.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n\n\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    }\n    /**\n     * Returns whether the current prototype/instance has a \"read only\"\n     * accessor for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n\n\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    }\n    /**\n     * Returns whether the current prototype/instance has a \"notify\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n\n\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    }\n    /**\n     * Returns whether the current prototype/instance has a \"reflect to\n     * attribute\" property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n\n\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    }\n    /**\n     * Returns whether the current prototype/instance has a \"computed\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n\n\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    } // Runtime ----------------------------------------\n\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @override\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n\n\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = get(this, path);\n          path =\n          /** @type {string} */\n          set(this, path, value); // Use property-accessor's simpler dirty check\n\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n\n        this.__dataHasPaths = true;\n\n        if (this._setPendingProperty(\n        /**@type{string}*/\n        path, value, shouldNotify)) {\n          computeLinkedPaths(this,\n          /**@type{string}*/\n          path, value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty(\n          /**@type{string}*/\n          path, value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Applies a value to a non-Polymer element/node's property.\n     *\n     * The implementation makes a best-effort at binding interop:\n     * Some native element properties have side-effects when\n     * re-setting the same value (e.g. setting `<input>.value` resets the\n     * cursor position), so we do a dirty-check before setting the value.\n     * However, for better interop with non-Polymer custom elements that\n     * accept objects, we explicitly re-set object changes coming from the\n     * Polymer world (which may include deep object changes without the\n     * top reference changing), erring on the side of providing more\n     * information.\n     *\n     * Users may override this method to provide alternate approaches.\n     *\n     * @override\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n\n\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        // Note, className needs style scoping so this needs wrapping.\n        if (prop === 'className') {\n          node =\n          /** @type {!Node} */\n          wrap(node);\n        }\n\n        node[prop] = value;\n      }\n    }\n    /**\n     * Overrides the `PropertiesChanged` implementation to introduce special\n     * dirty check logic depending on the property & value being set:\n     *\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n     * 2. Object set to simple property (e.g. 'prop': {...})\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\n     *    Stored in `__data`, dirty checked against `__data`\n     *\n     * The dirty-check is important to prevent cycles due to two-way\n     * notification, but paths and objects are only dirty checked against any\n     * previous value set during this turn via a \"temporary cache\" that is\n     * cleared when the last `_propertiesChanged` exits. This is so:\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n     *    due to array mutations like shift/unshift/splice; this is fine\n     *    since path changes are dirty-checked at user entry points like `set`\n     * b. dirty-checking for objects only lasts one turn to allow the user\n     *    to mutate the object in-place and re-set it with the same identity\n     *    and have all sub-properties re-propagated in a subsequent turn.\n     *\n     * The temp cache is not necessarily sufficient to prevent invalid array\n     * paths, since a splice can happen during the same turn (with pathological\n     * user code); we could introduce a \"fixup\" for temporarily cached array\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify True if property should fire notification\n     *   event (applies only for `notify: true` properties)\n     * @return {boolean} Returns true if the property changed\n     */\n\n\n    _setPendingProperty(property, value, shouldNotify) {\n      let propIsPath = this.__dataHasPaths && isPath(property);\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\n\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        } // Ensure old is captured from the last turn\n\n\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        } // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n\n\n        if (propIsPath) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        } // All changes go into pending property bag, passed to _propertiesChanged\n\n\n        this.__dataPending[property] = value; // Track properties that should notify separately\n\n        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\n     * to true, for per-property notification tracking.\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     */\n\n\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    }\n    /**\n     * Overrides `PropertyAccessor`'s default async queuing of\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n     * manually flushed), the function no-ops; otherwise flushes\n     * `_propertiesChanged` synchronously.\n     *\n     * @override\n     * @return {void}\n     */\n\n\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    }\n    /**\n     * Enqueues the given client on a list of pending clients, whose\n     * pending property changes can later be flushed via a call to\n     * `_flushClients`.\n     *\n     * @override\n     * @param {Object} client PropertyEffects client to enqueue\n     * @return {void}\n     * @protected\n     */\n\n\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    }\n    /**\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\n     * their `_flushProperties` method to run.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n\n\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n\n        this._readyClients(); // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n\n\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    } // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n\n\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n\n      if (clients) {\n        this.__dataPendingClients = null;\n\n        for (let i = 0; i < clients.length; i++) {\n          let client = clients[i];\n\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    }\n    /**\n     * Perform any initial setup on client dom. Called before the first\n     * `_flushProperties` call on client dom and before any element\n     * observers are called.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n\n\n    _readyClients() {\n      this.__enableOrFlushClients();\n    }\n    /**\n     * Sets a bag of property changes to this instance, and\n     * synchronously processes all effects of the properties as a batch.\n     *\n     * Property names must be simple properties, not paths.  Batched\n     * path propagation is not supported.\n     *\n     * @override\n     * @param {Object} props Bag of one or more key-value pairs whose key is\n     *   a property and value is the new value to set for that property.\n     * @param {boolean=} setReadOnly When true, any private values set in\n     *   `props` will be set. By default, `setProperties` will not set\n     *   `readOnly: true` root properties.\n     * @return {void}\n     * @public\n     */\n\n\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n\n      this._invalidateProperties();\n    }\n    /**\n     * Overrides `PropertyAccessors` so that property accessor\n     * side effects are not enabled until after client dom is fully ready.\n     * Also calls `_flushClients` callback to ensure client dom is enabled\n     * that was not enabled as a result of flushing properties.\n     *\n     * @override\n     * @return {void}\n     */\n\n\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties(); // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n\n\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      } // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n\n\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    }\n    /**\n     * Implements `PropertyAccessors`'s properties changed callback.\n     *\n     * Runs each class of effects for the batch of changed properties in\n     * a specific order (compute, propagate, reflect, observe, notify).\n     *\n     * @override\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     */\n\n\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false;\n      let notifyProps; // Compute properties\n\n      runComputedEffects(this, changedProps, oldProps, hasPaths); // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n\n      notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null; // Propagate properties to clients\n\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths); // Flush clients\n\n\n      this._flushClients(); // Reflect properties\n\n\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths); // Observe properties\n\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths); // Notify properties to host\n\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      } // Clear temporary cache at end of turn\n\n\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      } // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n\n    }\n    /**\n     * Called to propagate any property changes to stamped template nodes\n     * managed by this element.\n     *\n     * @override\n     * @param {Object} changedProps Bag of changed properties\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {void}\n     * @protected\n     */\n\n\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n\n      if (this.__templateInfo) {\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n      }\n    }\n\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n      const baseRunEffects = (changedProps, hasPaths) => {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n\n        for (let info = templateInfo.firstChild; info; info = info.nextSibling) {\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n        }\n      };\n\n      if (templateInfo.runEffects) {\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n      } else {\n        baseRunEffects(changedProps, hasPaths);\n      }\n    }\n    /**\n     * Aliases one data path as another, such that path notifications from one\n     * are routed to the other.\n     *\n     * @override\n     * @param {string | !Array<string|number>} to Target path to link.\n     * @param {string | !Array<string|number>} from Source path to link.\n     * @return {void}\n     * @public\n     */\n\n\n    linkPaths(to, from) {\n      to = normalize(to);\n      from = normalize(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    }\n    /**\n     * Removes a data path alias previously established with `_linkPaths`.\n     *\n     * Note, the path to unlink should be the target (`to`) used when\n     * linking the paths.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Target path to unlink.\n     * @return {void}\n     * @public\n     */\n\n\n    unlinkPaths(path) {\n      path = normalize(path);\n\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    }\n    /**\n     * Notify that an array has changed.\n     *\n     * Example:\n     *\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n     *     ...\n     *     this.items.splice(1, 1, {name: 'Sam'});\n     *     this.items.push({name: 'Bob'});\n     *     this.notifySplices('items', [\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n     *         object: this.items, type: 'splice' },\n     *       { index: 3, removed: [], addedCount: 1,\n     *         object: this.items, type: 'splice'}\n     *     ]);\n     *\n     * @param {string} path Path that should be notified.\n     * @param {Array} splices Array of splice records indicating ordered\n     *   changes that occurred to the array. Each record should have the\n     *   following fields:\n     *    * index: index at which the change occurred\n     *    * removed: array of items that were removed from this index\n     *    * addedCount: number of new items added at this index\n     *    * object: a reference to the array in question\n     *    * type: the string literal 'splice'\n     *\n     *   Note that splice records _must_ be normalized such that they are\n     *   reported in index order (raw results from `Object.observe` are not\n     *   ordered and must be normalized/merged before notifying).\n     *\n     * @override\n     * @return {void}\n     * @public\n     */\n\n\n    notifySplices(path, splices) {\n      let info = {\n        path: ''\n      };\n      let array =\n      /** @type {Array} */\n      get(this, path, info);\n      notifySplices(this, array, info.path, splices);\n    }\n    /**\n     * Convenience method for reading a value from a path.\n     *\n     * Note, if any part in the path is undefined, this method returns\n     * `undefined` (this method does not throw when dereferencing undefined\n     * paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n     * @param {Object=} root Root object from which the path is evaluated.\n     * @return {*} Value at the path, or `undefined` if any part of the path\n     *   is undefined.\n     * @public\n     */\n\n\n    get(path, root) {\n      return get(root || this, path);\n    }\n    /**\n     * Convenience method for setting a value to a path and notifying any\n     * elements bound to the same path.\n     *\n     * Note, if any part in the path except for the last is undefined,\n     * this method does nothing (this method does not throw when\n     * dereferencing undefined paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n     * @param {*} value Value to set at the specified path.\n     * @param {Object=} root Root object from which the path is evaluated.\n     *   When specified, no notification will occur.\n     * @return {void}\n     * @public\n     */\n\n\n    set(path, value, root) {\n      if (root) {\n        set(root, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][\n        /** @type {string} */\n        path]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    }\n    /**\n     * Adds items onto the end of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to push onto array\n     * @return {number} New length of the array.\n     * @public\n     */\n\n\n    push(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array =\n      /** @type {Array}*/\n      get(this, path, info);\n      let len = array.length;\n      let ret = array.push(...items);\n\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n\n      return ret;\n    }\n    /**\n     * Removes an item from the end of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n\n\n    pop(path) {\n      let info = {\n        path: ''\n      };\n      let array =\n      /** @type {Array} */\n      get(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n\n      return ret;\n    }\n    /**\n     * Starting from the start index specified, removes 0 or more items\n     * from the array and inserts 0 or more new items in their place.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.splice`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {number} start Index from which to start removing/inserting.\n     * @param {number=} deleteCount Number of items to remove.\n     * @param {...*} items Items to insert into array.\n     * @return {!Array} Array of removed items.\n     * @public\n     */\n\n\n    splice(path, start, deleteCount, ...items) {\n      let info = {\n        path: ''\n      };\n      let array =\n      /** @type {Array} */\n      get(this, path, info); // Normalize fancy native splice handling of crazy start values\n\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      } // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n\n\n      let ret; // Omit any additional arguments if they were not passed in\n\n      if (arguments.length === 2) {\n        ret = array.splice(start); // Either start was undefined and the others were defined, but in this\n        // case we can safely pass on all arguments\n        //\n        // Note: this includes the case where none of the arguments were passed in,\n        // e.g. this.splice('array'). However, if both start and deleteCount\n        // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      } // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n\n\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n\n      return ret;\n    }\n    /**\n     * Removes an item from the beginning of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n\n\n    shift(path) {\n      let info = {\n        path: ''\n      };\n      let array =\n      /** @type {Array} */\n      get(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n\n      return ret;\n    }\n    /**\n     * Adds items onto the beginning of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to insert info array\n     * @return {number} New length of the array.\n     * @public\n     */\n\n\n    unshift(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array =\n      /** @type {Array} */\n      get(this, path, info);\n      let ret = array.unshift(...items);\n\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n\n      return ret;\n    }\n    /**\n     * Notify that a path has changed.\n     *\n     * Example:\n     *\n     *     this.item.user.name = 'Bob';\n     *     this.notifyPath('item.user.name');\n     *\n     * @override\n     * @param {string} path Path that should be notified.\n     * @param {*=} value Value at the path (optional).\n     * @return {void}\n     * @public\n     */\n\n\n    notifyPath(path, value) {\n      /** @type {string} */\n      let propPath;\n\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {\n          path: ''\n        };\n        value = get(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = normalize(path);\n      } else {\n        propPath =\n        /** @type{string} */\n        path;\n      }\n\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    }\n    /**\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     */\n\n\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n\n      if (protectedSetter) {\n        this['_set' + upper(property)] =\n        /** @this {PropertyEffects} */\n        function (value) {\n          this._setProperty(property, value);\n        };\n      }\n    }\n    /**\n     * Equivalent to static `createPropertyObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method\n     *     to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n\n\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = {\n        property,\n        method,\n        dynamicFn: Boolean(dynamicFn)\n      };\n\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect,\n        info,\n        trigger: {\n          name: property\n        }\n      });\n\n      if (dynamicFn) {\n        this._addPropertyEffect(\n        /** @type {string} */\n        method, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info,\n          trigger: {\n            name: method\n          }\n        });\n      }\n    }\n    /**\n     * Equivalent to static `createMethodObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n\n\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    }\n    /**\n     * Equivalent to static `createNotifyingProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     */\n\n\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: camelToDashCase(property) + '-changed',\n          property: property\n        }\n      });\n    }\n    /**\n     * Equivalent to static `createReflectedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n\n\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    }\n    /**\n     * Equivalent to static `createComputedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n\n\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn); // Effects are normally stored as map of dependency->effect, but for\n      // ordered computation, we also need tree of computedProp->dependencies\n\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n    }\n    /**\n     * Gather the argument values for a method specified in the provided array\n     * of argument metadata.\n     *\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\n     * when the method is being called as a result of a path notification.\n     *\n     * @param {!Array<!MethodArg>} args Array of argument metadata\n     * @param {string} path Property/path name that triggered the method effect\n     * @param {Object} props Bag of current property changes\n     * @return {!Array<*>} Array of argument values\n     * @private\n     */\n\n\n    _marshalArgs(args, path, props) {\n      const data = this.__data;\n      const values = [];\n\n      for (let i = 0, l = args.length; i < l; i++) {\n        let {\n          name,\n          structured,\n          wildcard,\n          value,\n          literal\n        } = args[i];\n\n        if (!literal) {\n          if (wildcard) {\n            const matches = isDescendant(name, path);\n            const pathValue = getArgValue(data, props, matches ? path : name);\n            value = {\n              path: matches ? path : name,\n              value: pathValue,\n              base: matches ? get(data, name) : pathValue\n            };\n          } else {\n            value = structured ? getArgValue(data, props, name) : data[name];\n          }\n        } // When the `legacyUndefined` flag is enabled, pass a no-op value\n        // so that the observer, computed property, or compound binding is aborted.\n\n\n        if (legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n          return NOOP;\n        }\n\n        values[i] = value;\n      }\n\n      return values;\n    } // -- static class methods ------------\n\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    }\n    /**\n     * Creates a single-property observer for the given property.\n     *\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    }\n    /**\n     * Creates a multi-property \"method observer\" based on the provided\n     * expression, which should be a string in the form of a normal JavaScript\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n     * should correspond to a property or path in the context of this\n     * prototype (or instance), or may be a literal string or number.\n     *\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     * @return {void}\n     *   whether method names should be included as a dependency to the effect.\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    }\n    /**\n     * Causes the setter for the given property to dispatch `<property>-changed`\n     * events to notify of changes to the property.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    }\n    /**\n     * Creates a read-only accessor for the given property.\n     *\n     * To set the property, use the protected `_setProperty` API.\n     * To create a custom protected setter (e.g. `_setMyProp()` for\n     * property `myProp`), pass `true` for `protectedSetter`.\n     *\n     * Note, if the property will have other property effects, this method\n     * should be called first, before adding other effects.\n     *\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    }\n    /**\n     * Causes the setter for the given property to reflect the property value\n     * to a (dash-cased) attribute of the same name.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    }\n    /**\n     * Creates a computed property whose value is set to the result of the\n     * method described by the given `expression` each time one or more\n     * arguments to the method changes.  The expression should be a string\n     * in the form of a normal JavaScript function signature:\n     * `'methodName(arg1, [..., argn])'`\n     *\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n     *   method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    }\n    /**\n     * Parses the provided template to ensure binding effects are created\n     * for them, and then ensures property accessors are created for any\n     * dependent properties in the template.  Binding effects for bound\n     * templates are stored in a linked list on the instance so that\n     * templates can be efficiently stamped and unstamped.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @return {!TemplateInfo} Template metadata object\n     * @protected\n     * @nocollapse\n     */\n\n\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    } // -- binding ----------------------------------------------\n\n    /*\n     * Overview of binding flow:\n     *\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\n     *  the template (for the first time), and then assigns that _prototypical_\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n     *  this case `wasPreBound` is false; this is the first time we're binding\n     *  it, thus we create accessors.\n     *\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\n     *   of the template info to serve as the start of our linked list (needs to\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n     *   bindings, and so we can chain runtime-stamped template infos off of\n     *   it). At this point, the call to `_stampTemplate` calls\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n     *   `templateInfo` to the `<template>` so that we have the instance-time\n     *   parent to link the `templateInfo` under in the case it was\n     *   runtime-stamped.\n     *\n     * During subsequent runtime stamping (`instanceBinding==true`,\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n     *   because it was either a different template altogether, or even if it\n     *   was the same template, the step above created a instance of the info;\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n     *   link a instance into the linked list.\n     */\n\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on an instance\n     * to add effects at runtime.  See that method for full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @override\n     * @param {!HTMLTemplateElement} template Template containing binding\n     * bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     * \"prototypical\" binding of the template and overwrites any previously\n     * bound template for the class. When true (as passed from\n     * `_stampTemplate`), the template info is instanced and linked into the\n     * list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     * this is an instance of the prototypical template info\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n\n\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo; // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into tree of templates if necessary\n        templateInfo =\n        /** @type {!TemplateInfo} */\n        Object.create(templateInfo);\n        templateInfo.wasPreBound = wasPreBound;\n\n        if (!this.__templateInfo) {\n          // Set the info to the root of the tree\n          this.__templateInfo = templateInfo;\n        } else {\n          // Append this template info onto the end of its parent template's\n          // list, which will determine the tree structure via which property\n          // effects are run; if this template was not nested in another\n          // template, use the root template (the first stamped one) as the\n          // parent. Note, `parent` is the `templateInfo` instance for this\n          // template's parent (containing) template, which was set up in\n          // `applyTemplateInfo`.  While a given template's `parent` is set\n          // apriori, it is only added to the parent's child list at the point\n          // that it is being bound, since a template may or may not ever be\n          // stamped, and may be stamped more than once (in which case instances\n          // of the template info will be in the tree under its parent more than\n          // once).\n          const parent = template._parentTemplateInfo || this.__templateInfo;\n          const previous = parent.lastChild;\n          templateInfo.parent = parent;\n          parent.lastChild = templateInfo;\n          templateInfo.previousSibling = previous;\n\n          if (previous) {\n            previous.nextSibling = templateInfo;\n          } else {\n            parent.firstChild = templateInfo;\n          }\n        }\n      } else {\n        this.__preBoundTemplateInfo = templateInfo;\n      }\n\n      return templateInfo;\n    }\n    /**\n     * Adds a property effect to the given template metadata, which is run\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\n     * has been bound to the element via `_bindTemplate`.\n     *\n     * The `effect` object should match the format in `_addPropertyEffect`.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    }\n    /**\n     * Stamps the provided template and performs instance-time setup for\n     * Polymer template features, including data bindings, declarative event\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n     * is returned containing the stamped DOM, ready for insertion into the\n     * DOM.\n     *\n     * This method may be called more than once; however note that due to\n     * `shadycss` polyfill limitations, only styles from templates prepared\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n     * to the shadow root and support CSS custom properties), and note that\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n     * any styles required by in runtime-stamped templates must be included\n     * in the main element template.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically bound.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     * @protected\n     */\n\n\n    _stampTemplate(template, templateInfo) {\n      templateInfo = templateInfo ||\n      /** @type {!TemplateInfo} */\n      this._bindTemplate(template, true); // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n\n      hostStack.push(this);\n\n      let dom = super._stampTemplate(template, templateInfo);\n\n      hostStack.pop(); // Add template-instance-specific data to instanced templateInfo\n\n      templateInfo.nodeList = dom.nodeList; // Capture child nodes to allow unstamping of non-prototypical templates\n\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n\n        for (let n = dom.firstChild; n; n = n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n\n      dom.templateInfo = templateInfo; // Setup compound storage, 2-way listeners, and dataHost for bindings\n\n      setupBindings(this, templateInfo); // Flush properties into template nodes; the check on `__dataClientsReady`\n      // ensures we don't needlessly run effects for an element's initial\n      // prototypical template stamping since they will happen as a part of the\n      // first call to `_propertiesChanged`. This flag is set to true\n      // after running the initial propagate effects, and immediately before\n      // flushing clients. Since downstream clients could cause stamping on\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\n      // synchronously), this flag ensures effects for runtime-stamped templates\n      // are run at this point during the initial element boot-up.\n\n      if (this.__dataClientsReady) {\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n\n        this._flushClients();\n      }\n\n      return dom;\n    }\n    /**\n     * Removes and unbinds the nodes previously contained in the provided\n     * DocumentFragment returned from `_stampTemplate`.\n     *\n     * @override\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\n     *   from `_stampTemplate` associated with the nodes to be removed\n     * @return {void}\n     * @protected\n     */\n\n\n    _removeBoundDom(dom) {\n      // Unlink template info; Note that while the child is unlinked from its\n      // parent list, a template's `parent` reference is never removed, since\n      // this is is determined by the tree structure and applied at\n      // `applyTemplateInfo` time.\n      const templateInfo = dom.templateInfo;\n      const {\n        previousSibling,\n        nextSibling,\n        parent\n      } = templateInfo;\n\n      if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n      } else if (parent) {\n        parent.firstChild = nextSibling;\n      }\n\n      if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n      } else if (parent) {\n        parent.lastChild = previousSibling;\n      }\n\n      templateInfo.nextSibling = templateInfo.previousSibling = null; // Remove stamped nodes\n\n      let nodes = templateInfo.childNodes;\n\n      for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        wrap(wrap(node).parentNode).removeChild(node);\n      }\n    }\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNode.call(this, node, templateInfo, nodeInfo);\n\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n\n      return noted;\n    }\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from attributes.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property'; // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length - 1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        } // Initialize attribute bindings with any literal parts\n\n\n        let literal = literalFromParts(parts);\n\n        if (literal && kind == 'attribute') {\n          // Ensure a ShadyCSS template scoped style is not removed\n          // when a class$ binding's initial literal value is set.\n          if (name == 'class' && node.hasAttribute('class')) {\n            literal += ' ' + node.getAttribute(name);\n          }\n\n          node.setAttribute(name, literal);\n        } // support disable-upgrade\n\n\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\n          node.setAttribute(name, '');\n        } // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n\n\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        } // Remove annotation\n\n\n        node.removeAttribute(origName); // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n\n        if (kind === 'property') {\n          name = dashToCamelCase(name);\n        }\n\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(this, node, templateInfo, nodeInfo, name, value);\n      }\n    }\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * binding the properties that a nested template depends on to the template\n     * as `_host_<property>`.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(this, node, templateInfo, nodeInfo);\n\n      const parent = node.parentNode;\n      const nestedTemplateInfo = nodeInfo.templateInfo;\n      const isDomIf = parent.localName === 'dom-if';\n      const isDomRepeat = parent.localName === 'dom-repeat'; // Remove nested template and redirect its host bindings & templateInfo\n      // onto the parent (dom-if/repeat element)'s nodeInfo\n\n      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {\n        parent.removeChild(node); // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n        // templateInfo, and use that for any host property bindings below\n\n        nodeInfo = nodeInfo.parentInfo;\n        nodeInfo.templateInfo = nestedTemplateInfo; // Ensure the parent dom-if/repeat is noted since it now may have host\n        // bindings; it may not have been if it did not have its own bindings\n\n        nodeInfo.noted = true;\n        noted = false;\n      } // Merge host props into outer template and add bindings\n\n\n      let hostProps = nestedTemplateInfo.hostProps;\n\n      if (fastDomIf && isDomIf) {\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\n        // effects to properties used in its template; as such we don't need to\n        // tax the host element with `_host_` bindings for the `dom-if`.\n        // However, in the event it is nested in a `dom-repeat`, it is still\n        // important that its host properties are added to the\n        // TemplateInstance's `hostProps` so that they are forwarded to the\n        // TemplateInstance.\n        if (hostProps) {\n          templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps); // Ensure the dom-if is noted so that it has a __dataHost, since\n          // `fastDomIf` uses the host for runtime template stamping; note this\n          // was already ensured above in the `removeNestedTemplates` case\n\n          if (!removeNestedTemplates) {\n            nodeInfo.parentInfo.noted = true;\n          }\n        }\n      } else {\n        let mode = '{';\n\n        for (let source in hostProps) {\n          let parts = [{\n            mode,\n            source,\n            dependencies: [source],\n            hostProp: true\n          }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n      }\n\n      return noted;\n    }\n    /**\n     * Called to parse text in a template (either attribute values or\n     * textContent) into binding metadata.\n     *\n     * Any overrides of this method should return an array of binding part\n     * metadata  representing one or more bindings found in the provided text\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\n     * to `_evaluateBinding` when any dependencies change.  The only required\n     * fields of each \"part\" in the returned array are as follows:\n     *\n     * - `dependencies` - Array containing trigger metadata for each property\n     *   that should trigger the binding to update\n     * - `literal` - String containing text if the part represents a literal;\n     *   in this case no `dependencies` are needed\n     *\n     * Additional metadata for use by `_evaluateBinding` may be provided in\n     * each part object as needed.\n     *\n     * The default implementation handles the following types of bindings\n     * (one or more may be intermixed with literal strings):\n     * - Property binding: `[[prop]]`\n     * - Path binding: `[[object.prop]]`\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n     * - Two-way property or path bindings (supports negation):\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n     * - Inline computed method (supports negation):\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n     *\n     * The default implementation uses a regular expression for best\n     * performance. However, the regular expression uses a white-list of\n     * allowed characters in a data-binding, which causes problems for\n     * data-bindings that do use characters not in this white-list.\n     *\n     * Instead of updating the white-list with all allowed characters,\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n     * that uses a state machine instead. This state machine is able to handle\n     * all characters. However, it is slightly less performant, therefore we\n     * extracted it into a separate optional mixin.\n     *\n     * @param {string} text Text to parse from attribute or textContent\n     * @param {Object} templateInfo Current template metadata\n     * @return {Array<!BindingPart>} Array of binding part metadata\n     * @protected\n     * @nocollapse\n     */\n\n\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m; // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({\n            literal: text.slice(lastIndex, m.index)\n          });\n        } // Add binding part\n\n\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false,\n            notifyEvent = '',\n            colon = -1;\n\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n\n        let signature = parseMethod(source);\n        let dependencies = [];\n\n        if (signature) {\n          // Inline computed function\n          let {\n            args,\n            methodName\n          } = signature;\n\n          for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n\n          let dynamicFns = templateInfo.dynamicFns;\n\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n\n        parts.push({\n          source,\n          mode,\n          negate,\n          customEvent,\n          signature,\n          dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      } // Add a final literal part\n\n\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Called to evaluate a previously parsed binding part based on a set of\n     * one or more changed dependencies.\n     *\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\n     *     scope for binding dependencies\n     * @param {BindingPart} part Binding part metadata\n     * @param {string} path Property/path that triggered this effect\n     * @param {Object} props Bag of current property changes\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {*} Value the binding part evaluated to\n     * @protected\n     * @nocollapse\n     */\n\n\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = get(inst, part.source);\n      } else {\n        if (hasPaths && isPath(path)) {\n          value = get(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n\n      if (part.negate) {\n        value = !value;\n      }\n\n      return value;\n    }\n\n  }\n\n  return PropertyEffects;\n});\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\n\nconst hostStack = [];","map":{"version":3,"sources":["/storage/emulated/0/ict-folder/react-app/frontend/node_modules/@polymer/polymer/lib/mixins/property-effects.js"],"names":["wrap","dedupingMixin","root","isAncestor","isDescendant","get","translate","isPath","set","normalize","camelToDashCase","dashToCamelCase","PropertyAccessors","TemplateStamp","sanitizeDOMValue","legacyUndefined","orderedComputed","removeNestedTemplates","fastDomIf","dedupeId","NOOP","TYPES","COMPUTE","REFLECT","NOTIFY","PROPAGATE","OBSERVE","READ_ONLY","COMPUTE_INFO","capitalAttributeRegex","DataTrigger","DataEffect","ensureOwnEffectMap","model","type","cloneArrays","effects","hasOwnProperty","Object","create","p","protoFx","instFx","Array","length","i","runEffects","inst","props","oldProps","hasPaths","extraArgs","ran","id","prop","rootProperty","fxs","l","fx","info","lastRun","pathMatchesTrigger","trigger","fn","runEffectsForProperty","path","triggerPath","name","structured","wildcard","runObserverEffect","property","method","changedProp","call","__data","dynamicFn","console","warn","runNotifyEffects","notifyProps","notified","notifyPath","host","__dataHost","_invalidateProperties","eventName","dispatchNotifyEvent","value","detail","queueProperty","dispatchEvent","CustomEvent","runNotifyEffect","undefined","handleNotification","event","fromProp","toPath","negate","fromPath","currentTarget","_setPendingPropertyOrPath","Boolean","runReflectEffect","attrName","_propertyToAttribute","runComputedEffects","changedProps","computeEffects","order","getComputedOrder","queue","enqueueEffectsFor","shift","runComputedEffect","methodInfo","assign","__dataOld","__dataPending","inputProps","insertEffect","start","end","idx","mid","cmp","splice","ordered","constructor","__orderedComputedDeps","Map","counts","ready","total","dependencyCounts","curr","size","computedByCurr","forEach","computedProp","push","el","localName","infoForComputed","computedDeps","args","filter","a","literal","result","runMethodEffect","__dataHasAccessor","_setPendingProperty","computeLinkedPaths","links","__dataLinkedPaths","link","b","addBinding","templateInfo","nodeInfo","kind","target","parts","bindings","binding","isCompound","shouldAddListener","listenerEvent","listenerNegate","index","nodeInfoList","part","compoundIndex","addEffectForBindingPart","dependencies","evaluator","j","parseArg","_addTemplatePropertyEffect","runBindingEffect","nodeList","node","source","__isPropertyEffectsClient","_enqueueClient","_evaluateBinding","applyBindingValue","computeBindingValue","_valueToNodeAttribute","_setUnmanagedPropertyToNode","storage","__dataCompoundStorage","join","mode","setupBindings","setupCompoundStorage","addNotifyListener","literals","addEventListener","e","createMethodEffect","sig","effectFn","static","methodName","arg","_addPropertyEffect","context","_methodHost","_marshalArgs","apply","emptyArray","IDENT","NUMBER","SQUOTE_STRING","DQUOTE_STRING","STRING","ARGUMENT","ARGUMENTS","ARGUMENT_LIST","BINDING","OPEN_BRACKET","CLOSE_BRACKET","NEGATE","EXPRESSION","bindingRegex","RegExp","literalFromParts","s","parseMethod","expression","m","match","trim","replace","split","parseArgs","argList","map","rawArg","fc","slice","Number","getArgValue","data","notifySplices","array","splices","splicesData","indexSplices","_overrideLegacyUndefined","notifySplice","addedCount","removed","object","upper","toUpperCase","substring","PropertyEffects","superClass","propertyEffectsBase","__dataClientsReady","__dataPendingClients","__dataToNotify","__dataHasPaths","__dataTemp","__dataClientsInitialized","__computeEffects","__computeInfo","__reflectEffects","__notifyEffects","__propagateEffects","__observeEffects","__readOnly","__templateInfo","PROPERTY_EFFECT_TYPES","_initializeProperties","_registerHost","hostStack","_initializeProtoProperties","_initializeInstanceProperties","readOnly","effect","_createPropertyAccessor","_removePropertyEffect","indexOf","_hasPropertyEffect","_hasReadOnlyEffect","_hasNotifyEffect","_hasReflectEffect","_hasComputedEffect","shouldNotify","isPathNotification","isArray","old","_shouldPropertyChange","propIsPath","prevProps","_setProperty","__dataReady","_flushProperties","client","_flushClients","_readyClients","__enableOrFlushClients","clients","__dataEnabled","_enableProperties","setProperties","setReadOnly","_propertiesChanged","currentProps","_propagatePropertyChanges","__dataCounter","_runEffectsForTemplate","baseRunEffects","propertyEffects","firstChild","nextSibling","linkPaths","to","from","unlinkPaths","items","len","ret","pop","hadLength","deleteCount","Math","floor","arguments","unshift","propPath","_createReadOnlyProperty","protectedSetter","_createPropertyObserver","_createMethodObserver","Error","_createNotifyingProperty","_createReflectedProperty","attr","attributeNameForProperty","_createComputedProperty","values","matches","pathValue","base","addPropertyEffect","prototype","createPropertyObserver","createMethodObserver","createNotifyingProperty","createReadOnlyProperty","createReflectedProperty","createComputedProperty","bindTemplate","template","_bindTemplate","instanceBinding","_parseTemplate","wasPreBound","__preBoundTemplateInfo","parent","_parentTemplateInfo","previous","lastChild","previousSibling","hostProps","propEffects","_stampTemplate","dom","nodes","childNodes","n","_removeBoundDom","parentNode","removeChild","_parseTemplateNode","noted","nodeType","Node","TEXT_NODE","_parseBindings","textContent","_parseTemplateNodeAttribute","origName","test","hasAttribute","getAttribute","setAttribute","removeAttribute","_parseTemplateNestedTemplate","nestedTemplateInfo","isDomIf","isDomRepeat","parentInfo","hostProp","text","lastIndex","exec","customEvent","notifyEvent","colon","signature","dynamicFns"],"mappings":"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","sourcesContent":["/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport '../utils/boot.js';\nimport { wrap } from '../utils/wrap.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { root, isAncestor, isDescendant, get, translate, isPath, set, normalize } from '../utils/path.js';\n/* for notify, reflect */\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertyAccessors } from './property-accessors.js';\n/* for annotated effects */\nimport { TemplateStamp } from './template-stamp.js';\nimport { sanitizeDOMValue, legacyUndefined, orderedComputed, removeNestedTemplates, fastDomIf } from '../utils/settings.js';\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nlet dedupeId = 0;\n\nconst NOOP = [];\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\n\nconst COMPUTE_INFO = '__computeInfo';\n\n/** @const {!RegExp} */\nconst capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nlet DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nlet DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  let effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    if (cloneArrays) {\n      for (let p in effects) {\n        let protoFx = effects[p];\n        // Perf optimization over Array.slice\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i=0; i<protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    const id = dedupeId++;\n    for (let prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      let rootProperty = hasPaths ? root(prop) : prop;\n      let fxs = effects[rootProperty];\n      if (fxs) {\n        for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) &&\n              (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? root(prop) : prop;\n  let fxs = effects[rootProperty];\n  if (fxs) {\n    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath = /** @type {string} */ (trigger.name);\n    return (triggerPath == path) ||\n        !!(trigger.structured && isAncestor(triggerPath, path)) ||\n        !!(trigger.wildcard && isDescendant(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  let host;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  let rootProperty = root(path);\n  if (rootProperty !== path) {\n    let eventName = camelToDashCase(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n  wrap(/** @type {!HTMLElement} */(inst)).dispatchEvent(new CustomEvent(eventName, { detail }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? root(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? get(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property];  // specifically for .splices\n  }\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail = /** @type {Object} */(event.detail);\n  let fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = translate(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))\n      && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */(inst));\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    if (orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      const order = getComputedOrder(inst);\n      const queue = [];\n      for (let p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n      let info;\n      while ((info = queue.shift())) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n      Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\n      Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\n        Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\nconst insertEffect = (info, queue, order) => {\n  let start = 0;\n  let end = queue.length - 1;\n  let idx = -1;\n  while (start <= end) {\n    const mid = (start + end) >> 1;\n    // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n  if (idx < 0) {\n    idx = end + 1;\n  }\n  queue.splice(idx, 0, info);\n};\n\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\n  const rootProperty = hasPaths ? root(prop) : prop;\n  const fxs = computeEffects[rootProperty];\n  if (fxs) {\n    for (let i=0; i<fxs.length; i++) {\n      const fx = fxs[i];\n      if ((fx.info.lastRun !== dedupeId) &&\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\nfunction getComputedOrder(inst) {\n  let ordered = inst.constructor.__orderedComputedDeps;\n  if (!ordered) {\n    ordered = new Map();\n    const effects = inst[TYPES.COMPUTE];\n    let {counts, ready, total} = dependencyCounts(inst);\n    let curr;\n    while ((curr = ready.shift())) {\n      ordered.set(curr, ordered.size);\n      const computedByCurr = effects[curr];\n      if (computedByCurr) {\n        computedByCurr.forEach(fx => {\n          // Note `methodInfo` is where the computed property name is stored\n          const computedProp = fx.info.methodInfo;\n          --total;\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n    if (total !== 0) {\n      const el = /** @type {HTMLElement} */ (inst);\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\n    }\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n  return ordered;\n}\n\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\nfunction dependencyCounts(inst) {\n  const infoForComputed = inst[COMPUTE_INFO];\n  const counts = {};\n  const computedDeps = inst[TYPES.COMPUTE];\n  const ready = [];\n  let total = 0;\n  // Count dependencies for each computed property\n  for (let p in infoForComputed) {\n    const info = infoForComputed[p];\n    // Be sure to add the method name itself in case of \"dynamic functions\"\n    total += counts[p] =\n      info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\n  }\n  // Build list of ready properties (that aren't themselves computed)\n  for (let p in computedDeps) {\n    if (!infoForComputed[p]) {\n      ready.push(p);\n    }\n  }\n  return {counts, ready, total};\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info);\n  // Abort if method returns a no-op result\n  if (result === NOOP) {\n    return false;\n  }\n  let computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n  if (links) {\n    let link;\n    for (let a in links) {\n      let b = links[a];\n      if (isDescendant(a, path)) {\n        link = translate(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if (isDescendant(b, path)) {\n        link = translate(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    let {event, negate} = binding.parts[0];\n    binding.listenerEvent = event || (camelToDashCase(target) + '-changed');\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  let index = templateInfo.nodeInfoList.length;\n  for (let i=0; i<binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target +\n        ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = { index, binding, part, evaluator: constructor };\n      for (let j=0; j<dependencies.length; j++) {\n        let trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info, trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && (path.length > part.source.length) &&\n      (binding.kind == 'property') && !binding.isCompound &&\n      node.__isPropertyEffectsClient &&\n      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = translate(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    // Abort if value is a no-op result\n    if (value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n    if (node.__isPropertyEffectsClient &&\n        node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' ||\n        (binding.target === 'value' &&\n          (node.localName === 'input' || node.localName === 'textarea'))) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) &&\n         binding.kind != 'attribute' &&\n         binding.kind != 'text' &&\n         !binding.isCompound &&\n         binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {nodeList, nodeInfoList} = templateInfo;\n  if (nodeInfoList.length) {\n    for (let i=0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n      if (bindings) {\n        for (let i=0; i<bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage ||\n      (node.__dataCompoundStorage = {});\n    let parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    let literals = new Array(parts.length);\n    for (let j=0; j<parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    let target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = wrap(node);\n      }\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function(e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || (dynamicFn &&\n    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn, info: info, trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn, info: info\n    });\n  }\n  return info;\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n  if (fn) {\n    let args = inst._marshalArgs(info.args, property, props);\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nconst emptyArray = [];\n\n// Regular expressions used for binding\nconst IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                              '(?:' + ARGUMENTS + '?' + ')' +\n                            '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  let s = '';\n  for (let i=0; i<parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    let methodName = m[1];\n    let sig = { methodName, static: true, args: emptyArray };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function(rawArg) {\n    let arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim()\n    // replace comma entity with comma\n    .replace(/&comma;/g, ',')\n    // repair extra escape sequences; note only commas strictly need\n    // escaping, but we allow any other char to be escaped since its\n    // likely users will do this\n    .replace(/\\\\(.)/g, '\\$1')\n    ;\n  // basic argument descriptor\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  let fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch(fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = root(arg);\n    // detect structured path (has dots)\n    a.structured = isPath(arg);\n    if (a.structured) {\n      a.wildcard = (arg.slice(-2) == '.*');\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\n\nfunction getArgValue(data, props, path) {\n  let value = get(data, path);\n  // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n  if (value === undefined) {\n    value = props[path];\n  }\n  return value;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction notifySplices(inst, array, path, splices) {\n  const splicesData = { indexSplices: splices };\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length);\n  // Clear splice data only when it's stored on the array.\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\nexport const PropertyEffects = dedupingMixin(superClass => {\n\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n  class PropertyEffects extends propertyEffectsBase {\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n      this.__dataClientsReady;\n      /** @type {Array} */\n      this.__dataPendingClients;\n      /** @type {Object} */\n      this.__dataToNotify;\n      /** @type {Object} */\n      this.__dataLinkedPaths;\n      /** @type {boolean} */\n      this.__dataHasPaths;\n      /** @type {Object} */\n      this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      this.__dataHost;\n      /** @type {!Object} */\n      this.__dataTemp;\n      /** @type {boolean} */\n      this.__dataClientsInitialized;\n      /** @type {!Object} */\n      this.__data;\n      /** @type {!Object|null} */\n      this.__dataPending;\n      /** @type {!Object} */\n      this.__dataOld;\n      /** @type {Object} */\n      this.__computeEffects;\n      /** @type {Object} */\n      this.__computeInfo;\n      /** @type {Object} */\n      this.__reflectEffects;\n      /** @type {Object} */\n      this.__notifyEffects;\n      /** @type {Object} */\n      this.__propagateEffects;\n      /** @type {Object} */\n      this.__observeEffects;\n      /** @type {Object} */\n      this.__readOnly;\n      /** @type {!TemplateInfo} */\n      this.__templateInfo;\n      /** @type {boolean} */\n      this._overrideLegacyUndefined;\n    }\n\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      super._initializeProperties();\n      this._registerHost();\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false;\n      // May be set on instance prior to upgrade\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    }\n\n    _registerHost() {\n      if (hostStack.length) {\n        let host = hostStack[hostStack.length-1];\n        host._enqueueClient(this);\n        // This ensures even non-bound elements have a host set, as\n        // long as they upgrade synchronously\n        this.__dataHost = host;\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to provide a\n     * more efficient implementation of initializing properties from\n     * the prototype on the instance.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the prototype\n     * @return {void}\n     */\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to avoid setting\n     * `_setProperty`'s `shouldNotify: true`.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the instance\n     * @return {void}\n     */\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    }\n\n    // Prototype setup ----------------------------------------\n\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n      // effects are accumulated into arrays per property based on type\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n      effects.push(effect);\n    }\n\n    /**\n     * Removes the given property effect.\n     *\n     * @override\n     * @param {string} property Property the effect was associated with\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object to remove\n     * @return {void}\n     */\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      let idx = effects.indexOf(effect);\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a property effect\n     * of a certain type.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"read only\"\n     * accessor for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"notify\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"reflect to\n     * attribute\" property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"computed\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    }\n\n    // Runtime ----------------------------------------\n\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @override\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification ||\n          root(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = get(this, path);\n          path = /** @type {string} */ (set(this, path, value));\n          // Use property-accessor's simpler dirty check\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n        this.__dataHasPaths = true;\n        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {\n          computeLinkedPaths(this, /**@type{string}*/ (path), value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Applies a value to a non-Polymer element/node's property.\n     *\n     * The implementation makes a best-effort at binding interop:\n     * Some native element properties have side-effects when\n     * re-setting the same value (e.g. setting `<input>.value` resets the\n     * cursor position), so we do a dirty-check before setting the value.\n     * However, for better interop with non-Polymer custom elements that\n     * accept objects, we explicitly re-set object changes coming from the\n     * Polymer world (which may include deep object changes without the\n     * top reference changing), erring on the side of providing more\n     * information.\n     *\n     * Users may override this method to provide alternate approaches.\n     *\n     * @override\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        // Note, className needs style scoping so this needs wrapping.\n        if (prop === 'className') {\n          node = /** @type {!Node} */(wrap(node));\n        }\n        node[prop] = value;\n      }\n    }\n\n    /**\n     * Overrides the `PropertiesChanged` implementation to introduce special\n     * dirty check logic depending on the property & value being set:\n     *\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n     * 2. Object set to simple property (e.g. 'prop': {...})\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\n     *    Stored in `__data`, dirty checked against `__data`\n     *\n     * The dirty-check is important to prevent cycles due to two-way\n     * notification, but paths and objects are only dirty checked against any\n     * previous value set during this turn via a \"temporary cache\" that is\n     * cleared when the last `_propertiesChanged` exits. This is so:\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n     *    due to array mutations like shift/unshift/splice; this is fine\n     *    since path changes are dirty-checked at user entry points like `set`\n     * b. dirty-checking for objects only lasts one turn to allow the user\n     *    to mutate the object in-place and re-set it with the same identity\n     *    and have all sub-properties re-propagated in a subsequent turn.\n     *\n     * The temp cache is not necessarily sufficient to prevent invalid array\n     * paths, since a splice can happen during the same turn (with pathological\n     * user code); we could introduce a \"fixup\" for temporarily cached array\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify True if property should fire notification\n     *   event (applies only for `notify: true` properties)\n     * @return {boolean} Returns true if the property changed\n     */\n    _setPendingProperty(property, value, shouldNotify) {\n      let propIsPath = this.__dataHasPaths && isPath(property);\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        }\n        // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n        if (propIsPath) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        }\n        // All changes go into pending property bag, passed to _propertiesChanged\n        this.__dataPending[property] = value;\n        // Track properties that should notify separately\n        if (propIsPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\n     * to true, for per-property notification tracking.\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessor`'s default async queuing of\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n     * manually flushed), the function no-ops; otherwise flushes\n     * `_propertiesChanged` synchronously.\n     *\n     * @override\n     * @return {void}\n     */\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Enqueues the given client on a list of pending clients, whose\n     * pending property changes can later be flushed via a call to\n     * `_flushClients`.\n     *\n     * @override\n     * @param {Object} client PropertyEffects client to enqueue\n     * @return {void}\n     * @protected\n     */\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    }\n\n    /**\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\n     * their `_flushProperties` method to run.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n        this._readyClients();\n        // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    }\n\n    // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n      if (clients) {\n        this.__dataPendingClients = null;\n        for (let i=0; i < clients.length; i++) {\n          let client = clients[i];\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Perform any initial setup on client dom. Called before the first\n     * `_flushProperties` call on client dom and before any element\n     * observers are called.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _readyClients() {\n      this.__enableOrFlushClients();\n    }\n\n    /**\n     * Sets a bag of property changes to this instance, and\n     * synchronously processes all effects of the properties as a batch.\n     *\n     * Property names must be simple properties, not paths.  Batched\n     * path propagation is not supported.\n     *\n     * @override\n     * @param {Object} props Bag of one or more key-value pairs whose key is\n     *   a property and value is the new value to set for that property.\n     * @param {boolean=} setReadOnly When true, any private values set in\n     *   `props` will be set. By default, `setProperties` will not set\n     *   `readOnly: true` root properties.\n     * @return {void}\n     * @public\n     */\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n      this._invalidateProperties();\n    }\n\n    /**\n     * Overrides `PropertyAccessors` so that property accessor\n     * side effects are not enabled until after client dom is fully ready.\n     * Also calls `_flushClients` callback to ensure client dom is enabled\n     * that was not enabled as a result of flushing properties.\n     *\n     * @override\n     * @return {void}\n     */\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties();\n      // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      }\n      // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Implements `PropertyAccessors`'s properties changed callback.\n     *\n     * Runs each class of effects for the batch of changed properties in\n     * a specific order (compute, propagate, reflect, observe, notify).\n     *\n     * @override\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false;\n      let notifyProps;\n      // Compute properties\n      runComputedEffects(this, changedProps, oldProps, hasPaths);\n      // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n      notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null;\n      // Propagate properties to clients\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n      // Flush clients\n      this._flushClients();\n      // Reflect properties\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n      // Observe properties\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n      // Notify properties to host\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      }\n      // Clear temporary cache at end of turn\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      }\n      // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n    }\n\n    /**\n     * Called to propagate any property changes to stamped template nodes\n     * managed by this element.\n     *\n     * @override\n     * @param {Object} changedProps Bag of changed properties\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {void}\n     * @protected\n     */\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n      if (this.__templateInfo) {\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n      }\n    }\n\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n      const baseRunEffects = (changedProps, hasPaths) => {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,\n          hasPaths, templateInfo.nodeList);\n        for (let info=templateInfo.firstChild; info; info=info.nextSibling) {\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n        }\n      };\n      if (templateInfo.runEffects) {\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n      } else {\n        baseRunEffects(changedProps, hasPaths);\n      }\n    }\n\n    /**\n     * Aliases one data path as another, such that path notifications from one\n     * are routed to the other.\n     *\n     * @override\n     * @param {string | !Array<string|number>} to Target path to link.\n     * @param {string | !Array<string|number>} from Source path to link.\n     * @return {void}\n     * @public\n     */\n    linkPaths(to, from) {\n      to = normalize(to);\n      from = normalize(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    }\n\n    /**\n     * Removes a data path alias previously established with `_linkPaths`.\n     *\n     * Note, the path to unlink should be the target (`to`) used when\n     * linking the paths.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Target path to unlink.\n     * @return {void}\n     * @public\n     */\n    unlinkPaths(path) {\n      path = normalize(path);\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    }\n\n    /**\n     * Notify that an array has changed.\n     *\n     * Example:\n     *\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n     *     ...\n     *     this.items.splice(1, 1, {name: 'Sam'});\n     *     this.items.push({name: 'Bob'});\n     *     this.notifySplices('items', [\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n     *         object: this.items, type: 'splice' },\n     *       { index: 3, removed: [], addedCount: 1,\n     *         object: this.items, type: 'splice'}\n     *     ]);\n     *\n     * @param {string} path Path that should be notified.\n     * @param {Array} splices Array of splice records indicating ordered\n     *   changes that occurred to the array. Each record should have the\n     *   following fields:\n     *    * index: index at which the change occurred\n     *    * removed: array of items that were removed from this index\n     *    * addedCount: number of new items added at this index\n     *    * object: a reference to the array in question\n     *    * type: the string literal 'splice'\n     *\n     *   Note that splice records _must_ be normalized such that they are\n     *   reported in index order (raw results from `Object.observe` are not\n     *   ordered and must be normalized/merged before notifying).\n     *\n     * @override\n     * @return {void}\n     * @public\n     */\n    notifySplices(path, splices) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      notifySplices(this, array, info.path, splices);\n    }\n\n    /**\n     * Convenience method for reading a value from a path.\n     *\n     * Note, if any part in the path is undefined, this method returns\n     * `undefined` (this method does not throw when dereferencing undefined\n     * paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n     * @param {Object=} root Root object from which the path is evaluated.\n     * @return {*} Value at the path, or `undefined` if any part of the path\n     *   is undefined.\n     * @public\n     */\n    get(path, root) {\n      return get(root || this, path);\n    }\n\n    /**\n     * Convenience method for setting a value to a path and notifying any\n     * elements bound to the same path.\n     *\n     * Note, if any part in the path except for the last is undefined,\n     * this method does nothing (this method does not throw when\n     * dereferencing undefined paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n     * @param {*} value Value to set at the specified path.\n     * @param {Object=} root Root object from which the path is evaluated.\n     *   When specified, no notification will occur.\n     * @return {void}\n     * @public\n     */\n    set(path, value, root) {\n      if (root) {\n        set(root, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Adds items onto the end of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to push onto array\n     * @return {number} New length of the array.\n     * @public\n     */\n    push(path, ...items) {\n      let info = {path: ''};\n      let array = /** @type {Array}*/(get(this, path, info));\n      let len = array.length;\n      let ret = array.push(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the end of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    pop(path) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Starting from the start index specified, removes 0 or more items\n     * from the array and inserts 0 or more new items in their place.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.splice`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {number} start Index from which to start removing/inserting.\n     * @param {number=} deleteCount Number of items to remove.\n     * @param {...*} items Items to insert into array.\n     * @return {!Array} Array of removed items.\n     * @public\n     */\n    splice(path, start, deleteCount, ...items) {\n      let info = {path : ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      // Normalize fancy native splice handling of crazy start values\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      }\n      // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n      let ret;\n      // Omit any additional arguments if they were not passed in\n      if (arguments.length === 2) {\n        ret = array.splice(start);\n      // Either start was undefined and the others were defined, but in this\n      // case we can safely pass on all arguments\n      //\n      // Note: this includes the case where none of the arguments were passed in,\n      // e.g. this.splice('array'). However, if both start and deleteCount\n      // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      }\n      // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the beginning of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    shift(path) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Adds items onto the beginning of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to insert info array\n     * @return {number} New length of the array.\n     * @public\n     */\n    unshift(path, ...items) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      let ret = array.unshift(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Notify that a path has changed.\n     *\n     * Example:\n     *\n     *     this.item.user.name = 'Bob';\n     *     this.notifyPath('item.user.name');\n     *\n     * @override\n     * @param {string} path Path that should be notified.\n     * @param {*=} value Value at the path (optional).\n     * @return {void}\n     * @public\n     */\n    notifyPath(path, value) {\n      /** @type {string} */\n      let propPath;\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {path: ''};\n        value = get(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = normalize(path);\n      } else {\n        propPath = /** @type{string} */(path);\n      }\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     */\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n      if (protectedSetter) {\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {\n          this._setProperty(property, value);\n        };\n      }\n    }\n\n    /**\n     * Equivalent to static `createPropertyObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method\n     *     to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = { property, method, dynamicFn: Boolean(dynamicFn) };\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect, info, trigger: {name: property}\n      });\n      if (dynamicFn) {\n        this._addPropertyEffect(/** @type {string} */(method), TYPES.OBSERVE, {\n          fn: runObserverEffect, info, trigger: {name: method}\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createMethodObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    }\n\n    /**\n     * Equivalent to static `createNotifyingProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     */\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: camelToDashCase(property) + '-changed',\n          property: property\n        }\n      });\n    }\n\n    /**\n     * Equivalent to static `createReflectedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n          attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createComputedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      // Effects are normally stored as map of dependency->effect, but for\n      // ordered computation, we also need tree of computedProp->dependencies\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n    }\n\n    /**\n     * Gather the argument values for a method specified in the provided array\n     * of argument metadata.\n     *\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\n     * when the method is being called as a result of a path notification.\n     *\n     * @param {!Array<!MethodArg>} args Array of argument metadata\n     * @param {string} path Property/path name that triggered the method effect\n     * @param {Object} props Bag of current property changes\n     * @return {!Array<*>} Array of argument values\n     * @private\n     */\n    _marshalArgs(args, path, props) {\n      const data = this.__data;\n      const values = [];\n      for (let i=0, l=args.length; i<l; i++) {\n        let {name, structured, wildcard, value, literal} = args[i];\n        if (!literal) {\n          if (wildcard) {\n            const matches = isDescendant(name, path);\n            const pathValue = getArgValue(data, props, matches ? path : name);\n            value = {\n              path: matches ? path : name,\n              value: pathValue,\n              base: matches ? get(data, name) : pathValue\n            };\n          } else {\n            value = structured ? getArgValue(data, props, name) : data[name];\n          }\n        }\n        // When the `legacyUndefined` flag is enabled, pass a no-op value\n        // so that the observer, computed property, or compound binding is aborted.\n        if (legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n          return NOOP;\n        }\n        values[i] = value;\n      }\n      return values;\n    }\n\n    // -- static class methods ------------\n\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    }\n\n    /**\n     * Creates a single-property observer for the given property.\n     *\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    }\n\n    /**\n     * Creates a multi-property \"method observer\" based on the provided\n     * expression, which should be a string in the form of a normal JavaScript\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n     * should correspond to a property or path in the context of this\n     * prototype (or instance), or may be a literal string or number.\n     *\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     * @return {void}\n     *   whether method names should be included as a dependency to the effect.\n     * @protected\n     * @nocollapse\n     */\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    }\n\n    /**\n     * Causes the setter for the given property to dispatch `<property>-changed`\n     * events to notify of changes to the property.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    }\n\n    /**\n     * Creates a read-only accessor for the given property.\n     *\n     * To set the property, use the protected `_setProperty` API.\n     * To create a custom protected setter (e.g. `_setMyProp()` for\n     * property `myProp`), pass `true` for `protectedSetter`.\n     *\n     * Note, if the property will have other property effects, this method\n     * should be called first, before adding other effects.\n     *\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    }\n\n    /**\n     * Causes the setter for the given property to reflect the property value\n     * to a (dash-cased) attribute of the same name.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    }\n\n    /**\n     * Creates a computed property whose value is set to the result of the\n     * method described by the given `expression` each time one or more\n     * arguments to the method changes.  The expression should be a string\n     * in the form of a normal JavaScript function signature:\n     * `'methodName(arg1, [..., argn])'`\n     *\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n     *   method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    }\n\n    /**\n     * Parses the provided template to ensure binding effects are created\n     * for them, and then ensures property accessors are created for any\n     * dependent properties in the template.  Binding effects for bound\n     * templates are stored in a linked list on the instance so that\n     * templates can be efficiently stamped and unstamped.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @return {!TemplateInfo} Template metadata object\n     * @protected\n     * @nocollapse\n     */\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    }\n\n    // -- binding ----------------------------------------------\n\n    /*\n     * Overview of binding flow:\n     *\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\n     *  the template (for the first time), and then assigns that _prototypical_\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n     *  this case `wasPreBound` is false; this is the first time we're binding\n     *  it, thus we create accessors.\n     *\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\n     *   of the template info to serve as the start of our linked list (needs to\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n     *   bindings, and so we can chain runtime-stamped template infos off of\n     *   it). At this point, the call to `_stampTemplate` calls\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n     *   `templateInfo` to the `<template>` so that we have the instance-time\n     *   parent to link the `templateInfo` under in the case it was\n     *   runtime-stamped.\n     *\n     * During subsequent runtime stamping (`instanceBinding==true`,\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n     *   because it was either a different template altogether, or even if it\n     *   was the same template, the step above created a instance of the info;\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n     *   link a instance into the linked list.\n     */\n\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on an instance\n     * to add effects at runtime.  See that method for full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @override\n     * @param {!HTMLTemplateElement} template Template containing binding\n     * bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     * \"prototypical\" binding of the template and overwrites any previously\n     * bound template for the class. When true (as passed from\n     * `_stampTemplate`), the template info is instanced and linked into the\n     * list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     * this is an instance of the prototypical template info\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;\n      // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into tree of templates if necessary\n        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));\n        templateInfo.wasPreBound = wasPreBound;\n        if (!this.__templateInfo) {\n          // Set the info to the root of the tree\n          this.__templateInfo = templateInfo;\n        } else {\n          // Append this template info onto the end of its parent template's\n          // list, which will determine the tree structure via which property\n          // effects are run; if this template was not nested in another\n          // template, use the root template (the first stamped one) as the\n          // parent. Note, `parent` is the `templateInfo` instance for this\n          // template's parent (containing) template, which was set up in\n          // `applyTemplateInfo`.  While a given template's `parent` is set\n          // apriori, it is only added to the parent's child list at the point\n          // that it is being bound, since a template may or may not ever be\n          // stamped, and may be stamped more than once (in which case instances\n          // of the template info will be in the tree under its parent more than\n          // once).\n          const parent = template._parentTemplateInfo || this.__templateInfo;\n          const previous = parent.lastChild;\n          templateInfo.parent = parent;\n          parent.lastChild = templateInfo;\n          templateInfo.previousSibling = previous;\n          if (previous) {\n            previous.nextSibling = templateInfo;\n          } else {\n            parent.firstChild = templateInfo;\n          }\n        }\n      } else {\n        this.__preBoundTemplateInfo = templateInfo;\n      }\n      return templateInfo;\n    }\n\n    /**\n     * Adds a property effect to the given template metadata, which is run\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\n     * has been bound to the element via `_bindTemplate`.\n     *\n     * The `effect` object should match the format in `_addPropertyEffect`.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    }\n\n    /**\n     * Stamps the provided template and performs instance-time setup for\n     * Polymer template features, including data bindings, declarative event\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n     * is returned containing the stamped DOM, ready for insertion into the\n     * DOM.\n     *\n     * This method may be called more than once; however note that due to\n     * `shadycss` polyfill limitations, only styles from templates prepared\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n     * to the shadow root and support CSS custom properties), and note that\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n     * any styles required by in runtime-stamped templates must be included\n     * in the main element template.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically bound.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     * @protected\n     */\n    _stampTemplate(template, templateInfo) {\n      templateInfo =  templateInfo || /** @type {!TemplateInfo} */(this._bindTemplate(template, true));\n      // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n      hostStack.push(this);\n      let dom = super._stampTemplate(template, templateInfo);\n      hostStack.pop();\n      // Add template-instance-specific data to instanced templateInfo\n      templateInfo.nodeList = dom.nodeList;\n      // Capture child nodes to allow unstamping of non-prototypical templates\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n        for (let n=dom.firstChild; n; n=n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n      dom.templateInfo = templateInfo;\n      // Setup compound storage, 2-way listeners, and dataHost for bindings\n      setupBindings(this, templateInfo);\n      // Flush properties into template nodes; the check on `__dataClientsReady`\n      // ensures we don't needlessly run effects for an element's initial\n      // prototypical template stamping since they will happen as a part of the\n      // first call to `_propertiesChanged`. This flag is set to true\n      // after running the initial propagate effects, and immediately before\n      // flushing clients. Since downstream clients could cause stamping on\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\n      // synchronously), this flag ensures effects for runtime-stamped templates\n      // are run at this point during the initial element boot-up.\n      if (this.__dataClientsReady) {\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n        this._flushClients();\n      }\n      return dom;\n    }\n\n    /**\n     * Removes and unbinds the nodes previously contained in the provided\n     * DocumentFragment returned from `_stampTemplate`.\n     *\n     * @override\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\n     *   from `_stampTemplate` associated with the nodes to be removed\n     * @return {void}\n     * @protected\n     */\n    _removeBoundDom(dom) {\n      // Unlink template info; Note that while the child is unlinked from its\n      // parent list, a template's `parent` reference is never removed, since\n      // this is is determined by the tree structure and applied at\n      // `applyTemplateInfo` time.\n      const templateInfo = dom.templateInfo;\n      const {previousSibling, nextSibling, parent} = templateInfo;\n      if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n      } else if (parent) {\n        parent.firstChild = nextSibling;\n      }\n      if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n      } else if (parent) {\n        parent.lastChild = previousSibling;\n      }\n      templateInfo.nextSibling = templateInfo.previousSibling = null;\n      // Remove stamped nodes\n      let nodes = templateInfo.childNodes;\n      for (let i=0; i<nodes.length; i++) {\n        let node = nodes[i];\n        wrap(wrap(node).parentNode).removeChild(node);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNode.call(\n        this, node, templateInfo, nodeInfo);\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from attributes.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property';\n        // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length-1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        }\n        // Initialize attribute bindings with any literal parts\n        let literal = literalFromParts(parts);\n        if (literal && kind == 'attribute') {\n          // Ensure a ShadyCSS template scoped style is not removed\n          // when a class$ binding's initial literal value is set.\n          if (name == 'class' && node.hasAttribute('class')) {\n            literal += ' ' + node.getAttribute(name);\n          }\n          node.setAttribute(name, literal);\n        }\n        // support disable-upgrade\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\n          node.setAttribute(name, '');\n        }\n        // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        }\n        // Remove annotation\n        node.removeAttribute(origName);\n        // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n        if (kind === 'property') {\n          name = dashToCamelCase(name);\n        }\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(\n          this, node, templateInfo, nodeInfo, name, value);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * binding the properties that a nested template depends on to the template\n     * as `_host_<property>`.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(\n        this, node, templateInfo, nodeInfo);\n      const parent = node.parentNode;\n      const nestedTemplateInfo = nodeInfo.templateInfo;\n      const isDomIf = parent.localName === 'dom-if';\n      const isDomRepeat = parent.localName === 'dom-repeat';\n      // Remove nested template and redirect its host bindings & templateInfo\n      // onto the parent (dom-if/repeat element)'s nodeInfo\n      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {\n        parent.removeChild(node);\n        // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n        // templateInfo, and use that for any host property bindings below\n        nodeInfo = nodeInfo.parentInfo;\n        nodeInfo.templateInfo = nestedTemplateInfo;\n        // Ensure the parent dom-if/repeat is noted since it now may have host\n        // bindings; it may not have been if it did not have its own bindings\n        nodeInfo.noted = true;\n        noted = false;\n      }\n      // Merge host props into outer template and add bindings\n      let hostProps = nestedTemplateInfo.hostProps;\n      if (fastDomIf && isDomIf) {\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\n        // effects to properties used in its template; as such we don't need to\n        // tax the host element with `_host_` bindings for the `dom-if`.\n        // However, in the event it is nested in a `dom-repeat`, it is still\n        // important that its host properties are added to the\n        // TemplateInstance's `hostProps` so that they are forwarded to the\n        // TemplateInstance.\n        if (hostProps) {\n          templateInfo.hostProps =\n            Object.assign(templateInfo.hostProps || {}, hostProps);\n          // Ensure the dom-if is noted so that it has a __dataHost, since\n          // `fastDomIf` uses the host for runtime template stamping; note this\n          // was already ensured above in the `removeNestedTemplates` case\n          if (!removeNestedTemplates) {\n            nodeInfo.parentInfo.noted = true;\n          }\n        }\n      } else {\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{ mode, source, dependencies: [source], hostProp: true }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Called to parse text in a template (either attribute values or\n     * textContent) into binding metadata.\n     *\n     * Any overrides of this method should return an array of binding part\n     * metadata  representing one or more bindings found in the provided text\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\n     * to `_evaluateBinding` when any dependencies change.  The only required\n     * fields of each \"part\" in the returned array are as follows:\n     *\n     * - `dependencies` - Array containing trigger metadata for each property\n     *   that should trigger the binding to update\n     * - `literal` - String containing text if the part represents a literal;\n     *   in this case no `dependencies` are needed\n     *\n     * Additional metadata for use by `_evaluateBinding` may be provided in\n     * each part object as needed.\n     *\n     * The default implementation handles the following types of bindings\n     * (one or more may be intermixed with literal strings):\n     * - Property binding: `[[prop]]`\n     * - Path binding: `[[object.prop]]`\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n     * - Two-way property or path bindings (supports negation):\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n     * - Inline computed method (supports negation):\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n     *\n     * The default implementation uses a regular expression for best\n     * performance. However, the regular expression uses a white-list of\n     * allowed characters in a data-binding, which causes problems for\n     * data-bindings that do use characters not in this white-list.\n     *\n     * Instead of updating the white-list with all allowed characters,\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n     * that uses a state machine instead. This state machine is able to handle\n     * all characters. However, it is slightly less performant, therefore we\n     * extracted it into a separate optional mixin.\n     *\n     * @param {string} text Text to parse from attribute or textContent\n     * @param {Object} templateInfo Current template metadata\n     * @return {Array<!BindingPart>} Array of binding part metadata\n     * @protected\n     * @nocollapse\n     */\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m;\n      // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({literal: text.slice(lastIndex, m.index)});\n        }\n        // Add binding part\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false, notifyEvent = '', colon = -1;\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n        let signature = parseMethod(source);\n        let dependencies = [];\n        if (signature) {\n          // Inline computed function\n          let {args, methodName} = signature;\n          for (let i=0; i<args.length; i++) {\n            let arg = args[i];\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n          let dynamicFns = templateInfo.dynamicFns;\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n        parts.push({\n          source, mode, negate, customEvent, signature, dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      }\n      // Add a final literal part\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Called to evaluate a previously parsed binding part based on a set of\n     * one or more changed dependencies.\n     *\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\n     *     scope for binding dependencies\n     * @param {BindingPart} part Binding part metadata\n     * @param {string} path Property/path that triggered this effect\n     * @param {Object} props Bag of current property changes\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {*} Value the binding part evaluated to\n     * @protected\n     * @nocollapse\n     */\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = get(inst, part.source);\n      } else {\n        if (hasPaths && isPath(path)) {\n          value = get(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      if (part.negate) {\n        value = !value;\n      }\n      return value;\n    }\n\n  }\n\n  return PropertyEffects;\n});\n\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nconst hostStack = [];\n"]},"metadata":{},"sourceType":"module"}