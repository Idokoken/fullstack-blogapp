{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertiesChanged } from './properties-changed.js'; // Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\n\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\n\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n\n  for (let i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n\n  proto = Object.getPrototypeOf(proto);\n}\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\n\n\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\n\n\nexport const PropertyAccessors = dedupingMixin(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n  const base = PropertiesChanged(superClass);\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n\n  class PropertyAccessors extends base {\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     * @nocollapse\n     */\n    static createPropertiesForAttributes() {\n      let a$ =\n      /** @type {?} */\n      this.observedAttributes;\n\n      for (let i = 0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));\n      }\n    }\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n\n\n    static attributeNameForProperty(property) {\n      return camelToDashCase(property);\n    }\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n\n        this.__dataProto = null;\n      }\n\n      super._initializeProperties();\n    }\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n\n\n    _ensureAttribute(attribute, value) {\n      const el =\n      /** @type {!HTMLElement} */\n      this;\n\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n\n\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            try {\n              return JSON.stringify(value);\n            } catch (x) {\n              return '';\n            }\n          }\n\n        default:\n          return super._serializeValue(value);\n      }\n    }\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n\n\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      let outValue;\n\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse(\n            /** @type {string} */\n            value);\n          } catch (x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n\n          break;\n\n        case Array:\n          try {\n            outValue = JSON.parse(\n            /** @type {string} */\n            value);\n          } catch (x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n\n          break;\n\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n\n\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n\n      super._definePropertyAccessor(property, readOnly);\n    }\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n\n\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n\n\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && prop in this.__dataPending);\n    }\n\n  }\n\n  return PropertyAccessors;\n});","map":{"version":3,"sources":["C:/Users/Idokoken/Desktop/ict_exercise/projects/fullstack/fullstack-blogapp/frontend/node_modules/@polymer/polymer/lib/mixins/property-accessors.js"],"names":["dedupingMixin","camelToDashCase","dashToCamelCase","PropertiesChanged","nativeProperties","proto","HTMLElement","prototype","props","Object","getOwnPropertyNames","i","length","getPrototypeOf","saveAccessorValue","model","property","value","undefined","__data","_setPendingProperty","__dataProto","hasOwnProperty","JSCompiler_renameProperty","create","PropertyAccessors","superClass","base","createPropertiesForAttributes","a$","observedAttributes","_createPropertyAccessor","attributeNameForProperty","_initializeProperties","_initializeProtoProperties","p","_setProperty","_ensureAttribute","attribute","el","hasAttribute","_valueToNodeAttribute","_serializeValue","Date","toString","JSON","stringify","x","_deserializeValue","type","outValue","parse","Array","console","warn","isNaN","String","Number","_definePropertyAccessor","readOnly","_hasAccessor","__dataHasAccessor","_isPropertyPending","prop","Boolean","__dataPending"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kBAAP;AAEA,SAASA,aAAT,QAA8B,mBAA9B;AACA,SAASC,eAAT,EAA0BC,eAA1B,QAAiD,sBAAjD;AACA,SAASC,iBAAT,QAAkC,yBAAlC,C,CAEA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAG,EAAzB;AACA,IAAIC,KAAK,GAAGC,WAAW,CAACC,SAAxB;;AACA,OAAOF,KAAP,EAAc;AACZ,MAAIG,KAAK,GAAGC,MAAM,CAACC,mBAAP,CAA2BL,KAA3B,CAAZ;;AACA,OAAK,IAAIM,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACH,KAAK,CAACI,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AACjCP,IAAAA,gBAAgB,CAACI,KAAK,CAACG,CAAD,CAAN,CAAhB,GAA6B,IAA7B;AACD;;AACDN,EAAAA,KAAK,GAAGI,MAAM,CAACI,cAAP,CAAsBR,KAAtB,CAAR;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,iBAAT,CAA2BC,KAA3B,EAAkCC,QAAlC,EAA4C;AAC1C;AACA,MAAI,CAACZ,gBAAgB,CAACY,QAAD,CAArB,EAAiC;AAC/B,QAAIC,KAAK,GAAGF,KAAK,CAACC,QAAD,CAAjB;;AACA,QAAIC,KAAK,KAAKC,SAAd,EAAyB;AACvB,UAAIH,KAAK,CAACI,MAAV,EAAkB;AAChB;AACA;AACAJ,QAAAA,KAAK,CAACK,mBAAN,CAA0BJ,QAA1B,EAAoCC,KAApC;AACD,OAJD,MAIO;AACL;AACA,YAAI,CAACF,KAAK,CAACM,WAAX,EAAwB;AACtBN,UAAAA,KAAK,CAACM,WAAN,GAAoB,EAApB;AACD,SAFD,MAEO,IAAI,CAACN,KAAK,CAACO,cAAN,CAAqBC,yBAAyB,CAAC,aAAD,EAAgBR,KAAhB,CAA9C,CAAL,EAA4E;AACjFA,UAAAA,KAAK,CAACM,WAAN,GAAoBZ,MAAM,CAACe,MAAP,CAAcT,KAAK,CAACM,WAApB,CAApB;AACD;;AACDN,QAAAA,KAAK,CAACM,WAAN,CAAkBL,QAAlB,IAA8BC,KAA9B;AACD;AACF;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMQ,iBAAiB,GAAGzB,aAAa,CAAC0B,UAAU,IAAI;AAE3D;AACF;AACA;AACA;AACA;AACA;AACG,QAAMC,IAAI,GAAGxB,iBAAiB,CAACuB,UAAD,CAA9B;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,QAAMD,iBAAN,SAAgCE,IAAhC,CAAqC;AAEnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,WAAOC,6BAAP,GAAuC;AACrC,UAAIC,EAAE;AAAI;AAAkB,UAAD,CAAOC,kBAAlC;;AACA,WAAK,IAAInB,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAGkB,EAAE,CAACjB,MAArB,EAA6BD,CAAC,EAA9B,EAAkC;AAChC,aAAKJ,SAAL,CAAewB,uBAAf,CAAuC7B,eAAe,CAAC2B,EAAE,CAAClB,CAAD,CAAH,CAAtD;AACD;AACF;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAAOqB,wBAAP,CAAgChB,QAAhC,EAA0C;AACxC,aAAOf,eAAe,CAACe,QAAD,CAAtB;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIiB,IAAAA,qBAAqB,GAAG;AACtB,UAAI,KAAKZ,WAAT,EAAsB;AACpB,aAAKa,0BAAL,CAAgC,KAAKb,WAArC;;AACA,aAAKA,WAAL,GAAmB,IAAnB;AACD;;AACD,YAAMY,qBAAN;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,IAAAA,0BAA0B,CAAC1B,KAAD,EAAQ;AAChC,WAAK,IAAI2B,CAAT,IAAc3B,KAAd,EAAqB;AACnB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","sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertiesChanged } from './properties-changed.js';\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n  for (let i=0; i<props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const PropertyAccessors = dedupingMixin(superClass => {\n\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n   const base = PropertiesChanged(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  class PropertyAccessors extends base {\n\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     * @nocollapse\n     */\n    static createPropertiesForAttributes() {\n      let a$ =  /** @type {?} */ (this).observedAttributes;\n      for (let i=0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return camelToDashCase(property);\n    }\n\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n        this.__dataProto = null;\n      }\n      super._initializeProperties();\n    }\n\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n    _ensureAttribute(attribute, value) {\n      const el = /** @type {!HTMLElement} */(this);\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            try {\n              return JSON.stringify(value);\n            } catch(x) {\n              return '';\n            }\n          }\n\n        default:\n          return super._serializeValue(value);\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      let outValue;\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse(/** @type {string} */(value));\n          } catch(x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n          break;\n        case Array:\n          try {\n            outValue = JSON.parse(/** @type {string} */(value));\n          } catch(x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n          break;\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n      super._definePropertyAccessor(property, readOnly);\n    }\n\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && (prop in this.__dataPending));\n    }\n\n  }\n\n  return PropertyAccessors;\n\n});\n"]},"metadata":{},"sourceType":"module"}