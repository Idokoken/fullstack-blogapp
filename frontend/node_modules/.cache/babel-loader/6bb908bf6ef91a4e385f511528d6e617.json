{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\nimport './boot.js'; // Microtask implemented using Mutation Observer\n\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\n\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\n\n\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n\n    };\n  },\n\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n\n};\nexport { timeOut };\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\n\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n\n};\nexport { animationFrame };\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\n\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n\n};\nexport { idlePeriod };\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\n\nconst microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\nexport { microTask };","map":{"version":3,"sources":["/storage/emulated/0/ict-folder/react-app/frontend/node_modules/@polymer/polymer/lib/utils/async.js"],"names":["microtaskCurrHandle","microtaskLastHandle","microtaskCallbacks","microtaskNodeContent","microtaskScheduled","microtaskNode","document","createTextNode","window","MutationObserver","microtaskFlush","observe","characterData","len","length","i","cb","e","setTimeout","splice","timeOut","after","delay","run","fn","cancel","handle","clearTimeout","animationFrame","requestAnimationFrame","cancelAnimationFrame","idlePeriod","requestIdleCallback","cancelIdleCallback","microTask","callback","textContent","push","idx","Error"],"mappings":"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","sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\nimport './boot.js';\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});\n\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => { throw e; });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) { return window.setTimeout(fn, delay); },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\nexport {timeOut};\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\nexport {animationFrame};\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ?\n      window.requestIdleCallback(fn) :\n      window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ?\n      window.cancelIdleCallback(handle) :\n      window.clearTimeout(handle);\n  }\n};\nexport {idlePeriod};\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\nexport {microTask};\n"]},"metadata":{},"sourceType":"module"}