{"ast":null,"code":"/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport '../utils/boot.js';\nimport { rootPath, strictTemplatePolicy, allowTemplateFromDomModule, legacyOptimizations, legacyWarnings, syncInitialRender, supportsAdoptingStyleSheets, useAdoptedStyleSheetsWithBuiltCSS } from '../utils/settings.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { stylesFromTemplate, stylesFromModuleImports } from '../utils/style-gather.js';\nimport { pathFromUrl, resolveCss, resolveUrl } from '../utils/resolve-url.js';\nimport { DomModule } from '../elements/dom-module.js';\nimport { PropertyEffects } from './property-effects.js';\nimport { PropertiesMixin } from './properties-mixin.js';\nimport { wrap } from '../utils/wrap.js';\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\n\nexport const version = '3.4.1';\nexport const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\n\nexport const ElementMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = PropertiesMixin(PropertyEffects(base));\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n\n      for (let p in props) {\n        let info = props[p];\n\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n\n    return constructor.__propertyDefaults;\n  }\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n\n\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?\n      /** @type {PolymerElementConstructor} */\n      constructor.observers : null;\n    }\n\n    return constructor.__ownObservers;\n  }\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n\n\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    } // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n\n\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    } // always add observer\n\n\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    } // always create the mapping from attribute back to property for deserialization.\n\n\n    proto._addPropertyToAttributeMap(name);\n  }\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n\n\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = stylesFromTemplate(template); // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n\n      const linkedStyles = stylesFromModuleImports(is);\n      const firstTemplateChild = template.content.firstElementChild;\n\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      } // keep track of the last \"concrete\" style in the template we have encountered\n\n\n      let templateStyleIndex = 0; // ensure all gathered styles are actually in this template.\n\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex]; // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    } // Support for `adoptedStylesheets` relies on using native Shadow DOM\n    // and built CSS. Built CSS is required because runtime transformation of\n    // `@apply` is not supported. This is because ShadyCSS relies on being able\n    // to update a `style` element in the element template and this is\n    // removed when using `adoptedStyleSheets`.\n    // Note, it would be more efficient to allow style includes to become\n    // separate stylesheets; however, because of `@apply` these are\n    // potentially not shareable and sharing the ones that could be shared\n    // would require some coordination. To keep it simple, all the includes\n    // and styles are collapsed into a single shareable stylesheet.\n\n\n    if (useAdoptedStyleSheetsWithBuiltCSS && builtCSS && supportsAdoptingStyleSheets) {\n      // Remove styles in template and make a shareable stylesheet\n      const styles = template.content.querySelectorAll('style');\n\n      if (styles) {\n        let css = '';\n        Array.from(styles).forEach(s => {\n          css += s.textContent;\n          s.parentNode.removeChild(s);\n        });\n        klass._styleSheet = new CSSStyleSheet();\n\n        klass._styleSheet.replaceSync(css);\n      }\n    }\n  }\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n\n\n  function getTemplateFromDomModule(is) {\n    let template = null; // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n\n    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {\n      template =\n      /** @type {?HTMLTemplateElement} */\n      DomModule.import(is, 'template'); // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n\n      if (strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n\n    return template;\n  }\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n\n\n  class PolymerElement extends polymerElementBase {\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     * @nocollapse\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n\n\n    static _finalizeClass() {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      polymerElementBase._finalizeClass.call(this);\n\n      const observers = ownObservers(this);\n\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n\n      this._prepareTemplate();\n    }\n    /** @nocollapse */\n\n\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template =\n      /** @type {PolymerElementConstructor} */\n      this.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n      /** @override */\n\n\n      this.prototype._template = template;\n    }\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig(\n        /** @type {?} */\n        this.prototype, p, props[p], props);\n      }\n    }\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n\n\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n\n      for (let i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation will\n     * return the first `<template>` in a `dom-module` whose `id` matches this\n     * element's `is` (note that a `_template` property on the class prototype\n     * takes precedence over the `dom-module` template, to maintain legacy\n     * element semantics; a subclass will subsequently fall back to its super\n     * class template if neither a `prototype._template` or a `dom-module` for\n     * the class's `is` was found).\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     * @nocollapse\n     */\n\n\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        const protoTemplate = this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : undefined;\n        this._template = // If user has put template on prototype (e.g. in legacy via registered\n        // callback or info object), prefer that first. Note that `null` is\n        // used as a sentinel to indicate \"no template\" and can be used to\n        // override a super template, whereas `undefined` is used as a\n        // sentinel to mean \"fall-back to default template lookup\" via\n        // dom-module and/or super.template.\n        protoTemplate !== undefined ? protoTemplate : // Look in dom-module associated with this element's is\n        this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && getTemplateFromDomModule(\n        /** @type {PolymerElementConstructor}*/\n        this.is) || // Next look for superclass template (call the super impl this\n        // way so that `this` points to the superclass)\n        Object.getPrototypeOf(\n        /** @type {PolymerElementConstructor}*/\n        this.prototype).constructor.template;\n      }\n\n      return this._template;\n    }\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     * @nocollapse\n     */\n\n\n    static set template(value) {\n      this._template = value;\n    }\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     * @nocollapse\n     */\n\n\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n\n        if (meta) {\n          this._importPath = pathFromUrl(meta.url);\n        } else {\n          const module = DomModule.import(\n          /** @type {PolymerElementConstructor} */\n          this.is);\n          this._importPath = module && module.assetpath || Object.getPrototypeOf(\n          /** @type {PolymerElementConstructor}*/\n          this.prototype).constructor.importPath;\n        }\n      }\n\n      return this._importPath;\n    }\n\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n\n      this._template;\n      /** @type {string} */\n\n      this._importPath;\n      /** @type {string} */\n\n      this.rootPath;\n      /** @type {string} */\n\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n\n      this.root;\n      /** @type {!Object<string, !Element>} */\n\n      this.$;\n    }\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n\n\n    _initializeProperties() {\n      this.constructor.finalize(); // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n\n      this.constructor._finalizeTemplate(\n      /** @type {!HTMLElement} */\n      this.localName);\n\n      super._initializeProperties(); // set path defaults\n\n\n      this.rootPath = rootPath;\n      this.importPath = this.constructor.importPath; // apply property defaults...\n\n      let p$ = propertyDefaults(this.constructor);\n\n      if (!p$) {\n        return;\n      }\n\n      for (let p in p$) {\n        let info = p$[p];\n\n        if (this._canApplyPropertyDefault(p)) {\n          let value = typeof info.value == 'function' ? info.value.call(this) : info.value; // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n    /**\n     * Determines if a property dfeault can be applied. For example, this\n     * prevents a default from being applied when a property that has no\n     * accessor is overridden by its host before upgrade (e.g. via a binding).\n     * @override\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property default can be applied.\n     */\n\n\n    _canApplyPropertyDefault(property) {\n      return !this.hasOwnProperty(property);\n    }\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     * @nocollapse\n     */\n\n\n    static _processStyleText(cssText, baseURI) {\n      return resolveCss(cssText, baseURI);\n    }\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    * @nocollapse\n    */\n\n\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? resolveUrl(importPath) : ''; // e.g. support `include=\"module-name\"`, and ShadyCSS\n\n        processElementStyles(this, template, is, baseURI);\n\n        this.prototype._bindTemplate(template);\n      }\n    }\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n\n\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement(\n        /** @type {!HTMLElement} */\n        this);\n      }\n\n      super.connectedCallback();\n    }\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n\n\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n\n      super.ready();\n    }\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n\n\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom(\n        /** @type {StampedTemplate} */\n        this.root);\n      } // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n\n\n      super._readyClients();\n    }\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n\n\n    _attachDom(dom) {\n      const n = wrap(this);\n\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({\n              mode: 'open',\n              shadyUpgradeFragment: dom\n            });\n            n.shadowRoot.appendChild(dom); // When `adoptedStyleSheets` is supported a stylesheet is made\n            // available on the element constructor.\n\n            if (this.constructor._styleSheet) {\n              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];\n            }\n          }\n\n          if (syncInitialRender && window.ShadyDOM) {\n            window.ShadyDOM.flushInitial(n.shadowRoot);\n          }\n\n          return n.shadowRoot;\n        }\n\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' + // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n\n\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree(\n        /** @type {!HTMLElement} */\n        this, properties);\n      }\n    }\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n\n\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = resolveUrl(this.importPath);\n      }\n\n      return resolveUrl(url, base);\n    }\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n\n\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties; // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n\n      return polymerElementBase._parseTemplateContent.call(this, template, templateInfo, nodeInfo);\n    }\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n\n\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (legacyWarnings && !(prop in this._properties) && // Methods used in templates with no dependencies (or only literal\n      // dependencies) become accessors with template effects; ignore these\n      !(effect.info.part.signature && effect.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by\n      // templatizer so ignore both the host-to-template bindings\n      // (`hostProp`) and TemplateInstance-to-child bindings\n      // (`nestedTemplate`)\n      !effect.info.part.hostProp && !templateInfo.nestedTemplate) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);\n      } // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n\n\n      return polymerElementBase._addTemplatePropertyEffect.call(this, templateInfo, prop, effect);\n    }\n\n  }\n\n  return PolymerElement;\n});\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\n\nexport const updateStyles = function (props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};","map":{"version":3,"sources":["C:/Users/Idokoken/Desktop/ict_exercise/projects/fullstack/fullstack-blogapp/frontend/node_modules/@polymer/polymer/lib/mixins/element-mixin.js"],"names":["rootPath","strictTemplatePolicy","allowTemplateFromDomModule","legacyOptimizations","legacyWarnings","syncInitialRender","supportsAdoptingStyleSheets","useAdoptedStyleSheetsWithBuiltCSS","dedupingMixin","stylesFromTemplate","stylesFromModuleImports","pathFromUrl","resolveCss","resolveUrl","DomModule","PropertyEffects","PropertiesMixin","wrap","version","builtCSS","window","ShadyCSS","ElementMixin","base","polymerElementBase","propertyDefaults","constructor","hasOwnProperty","JSCompiler_renameProperty","__propertyDefaults","props","_properties","p","info","ownObservers","__ownObservers","observers","createPropertyFromConfig","proto","name","allProps","computed","readOnly","_hasReadOnlyEffect","console","warn","_createComputedProperty","_createReadOnlyProperty","reflectToAttribute","_hasReflectEffect","_createReflectedProperty","notify","_hasNotifyEffect","_createNotifyingProperty","observer","_createPropertyObserver","_addPropertyToAttributeMap","processElementStyles","klass","template","is","baseURI","templateStyles","content","querySelectorAll","stylesWithImports","linkedStyles","firstTemplateChild","firstElementChild","idx","length","s","textContent","_processStyleText","insertBefore","templateStyleIndex","i","templateStyle","cloneNode","parentNode","prepareTemplate","styles","css","Array","from","forEach","removeChild","_styleSheet","CSSStyleSheet","replaceSync","getTemplateFromDomModule","import","Error","PolymerElement","polymerElementVersion","_finalizeClass","call","createObservers","_prepareTemplate","error","prototype","_template","createProperties","dynamicFns","_createMethodObserver","protoTemplate","undefined","Object","getPrototypeOf","value","importPath","meta","importMeta","_importPath","url","module","assetpath","root","$","_initializeProperties","finalize","_finalizeTemplate","localName","p$","_canApplyPropertyDefault","_hasAccessor","_setPendingProperty","property","cssText","__polymerFinalized","_bindTemplate","connectedCallback","styleElement","ready","_stampTemplate","_readyClients","_attachDom","dom","n","attachShadow","shadowRoot","mode","shadyUpgradeFragment","appendChild","adoptedStyleSheets","ShadyDOM","flushInitial","updateStyles","properties","styleSubtree","_parseTemplateContent","templateInfo","nodeInfo","_addTemplatePropertyEffect","prop","effect","part","signature","static","hostProp","nestedTemplate","styleDocument"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kBAAP;AAEA,SAASA,QAAT,EAAmBC,oBAAnB,EAAyCC,0BAAzC,EAAqEC,mBAArE,EAA0FC,cAA1F,EAA0GC,iBAA1G,EAA6HC,2BAA7H,EAA0JC,iCAA1J,QAAmM,sBAAnM;AACA,SAASC,aAAT,QAA8B,mBAA9B;AACA,SAASC,kBAAT,EAA6BC,uBAA7B,QAA4D,0BAA5D;AACA,SAASC,WAAT,EAAsBC,UAAtB,EAAkCC,UAAlC,QAAoD,yBAApD;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,SAASC,IAAT,QAAqB,kBAArB;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,OAAO,GAAG,OAAhB;AAEP,OAAO,MAAMC,QAAQ,GAAGC,MAAM,CAACC,QAAP,IAAmBD,MAAM,CAACC,QAAP,CAAgB,UAAhB,CAApC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,YAAY,GAAGd,aAAa,CAACe,IAAI,IAAI;AAChD;AACF;AACA;AACA;AACA;AACA;AACA;AACE,QAAMC,kBAAkB,GAAGR,eAAe,CAACD,eAAe,CAACQ,IAAD,CAAhB,CAA1C;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,WAASE,gBAAT,CAA0BC,WAA1B,EAAuC;AACrC,QAAI,CAACA,WAAW,CAACC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","sourcesContent":["/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport '../utils/boot.js';\n\nimport { rootPath, strictTemplatePolicy, allowTemplateFromDomModule, legacyOptimizations, legacyWarnings, syncInitialRender, supportsAdoptingStyleSheets, useAdoptedStyleSheetsWithBuiltCSS } from '../utils/settings.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { stylesFromTemplate, stylesFromModuleImports } from '../utils/style-gather.js';\nimport { pathFromUrl, resolveCss, resolveUrl } from '../utils/resolve-url.js';\nimport { DomModule } from '../elements/dom-module.js';\nimport { PropertyEffects } from './property-effects.js';\nimport { PropertiesMixin } from './properties-mixin.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\nexport const version = '3.4.1';\n\nexport const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const ElementMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = PropertiesMixin(PropertyEffects(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(\n      JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n      for (let p in props) {\n        let info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(\n      JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers =\n          constructor.hasOwnProperty(\n              JSCompiler_renameProperty('observers', constructor)) ?\n          /** @type {PolymerElementConstructor} */ (constructor).observers :\n          null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = stylesFromTemplate(template);\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n      const linkedStyles = stylesFromModuleImports(is);\n      const firstTemplateChild = template.content.firstElementChild;\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      }\n      // keep track of the last \"concrete\" style in the template we have encountered\n      let templateStyleIndex = 0;\n      // ensure all gathered styles are actually in this template.\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex];\n        // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n    // Support for `adoptedStylesheets` relies on using native Shadow DOM\n    // and built CSS. Built CSS is required because runtime transformation of\n    // `@apply` is not supported. This is because ShadyCSS relies on being able\n    // to update a `style` element in the element template and this is\n    // removed when using `adoptedStyleSheets`.\n    // Note, it would be more efficient to allow style includes to become\n    // separate stylesheets; however, because of `@apply` these are\n    // potentially not shareable and sharing the ones that could be shared\n    // would require some coordination. To keep it simple, all the includes\n    // and styles are collapsed into a single shareable stylesheet.\n    if (useAdoptedStyleSheetsWithBuiltCSS && builtCSS &&\n        supportsAdoptingStyleSheets) {\n      // Remove styles in template and make a shareable stylesheet\n      const styles = template.content.querySelectorAll('style');\n      if (styles) {\n        let css = '';\n        Array.from(styles).forEach(s => {\n          css += s.textContent;\n          s.parentNode.removeChild(s);\n        });\n        klass._styleSheet = new CSSStyleSheet();\n        klass._styleSheet.replaceSync(css);\n      }\n    }\n  }\n\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n  function getTemplateFromDomModule(is) {\n    let template = null;\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {\n      template = /** @type {?HTMLTemplateElement} */ (\n          DomModule.import(is, 'template'));\n      // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n      if (strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n    return template;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n  class PolymerElement extends polymerElementBase {\n\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     * @nocollapse\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _finalizeClass() {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      polymerElementBase._finalizeClass.call(this);\n      const observers = ownObservers(this);\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n      this._prepareTemplate();\n    }\n\n    /** @nocollapse */\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type {PolymerElementConstructor} */ (this).template;\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n\n      /** @override */\n      this.prototype._template = template;\n    }\n\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig(\n            /** @type {?} */ (this.prototype), p, props[p], props);\n      }\n    }\n\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n      for (let i=0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation will\n     * return the first `<template>` in a `dom-module` whose `id` matches this\n     * element's `is` (note that a `_template` property on the class prototype\n     * takes precedence over the `dom-module` template, to maintain legacy\n     * element semantics; a subclass will subsequently fall back to its super\n     * class template if neither a `prototype._template` or a `dom-module` for\n     * the class's `is` was found).\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     * @nocollapse\n     */\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        const protoTemplate = this.prototype.hasOwnProperty(\n          JSCompiler_renameProperty('_template', this.prototype)) ?\n          this.prototype._template : undefined;\n        this._template =\n          // If user has put template on prototype (e.g. in legacy via registered\n          // callback or info object), prefer that first. Note that `null` is\n          // used as a sentinel to indicate \"no template\" and can be used to\n          // override a super template, whereas `undefined` is used as a\n          // sentinel to mean \"fall-back to default template lookup\" via\n          // dom-module and/or super.template.\n          protoTemplate !== undefined ? protoTemplate :\n          // Look in dom-module associated with this element's is\n          ((this.hasOwnProperty(JSCompiler_renameProperty('is', this)) &&\n          (getTemplateFromDomModule(/** @type {PolymerElementConstructor}*/ (this).is))) ||\n          // Next look for superclass template (call the super impl this\n          // way so that `this` points to the superclass)\n          Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.template);\n      }\n      return this._template;\n    }\n\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     * @nocollapse\n     */\n    static set template(value) {\n      this._template = value;\n    }\n\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     * @nocollapse\n     */\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n        if (meta) {\n          this._importPath = pathFromUrl(meta.url);\n        } else {\n          const module = DomModule.import(/** @type {PolymerElementConstructor} */ (this).is);\n          this._importPath = (module && module.assetpath) ||\n            Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.importPath;\n        }\n      }\n      return this._importPath;\n    }\n\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n      this._template;\n      /** @type {string} */\n      this._importPath;\n      /** @type {string} */\n      this.rootPath;\n      /** @type {string} */\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root;\n      /** @type {!Object<string, !Element>} */\n      this.$;\n    }\n\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n    _initializeProperties() {\n      this.constructor.finalize();\n      // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n      this.constructor._finalizeTemplate(/** @type {!HTMLElement} */(this).localName);\n      super._initializeProperties();\n      // set path defaults\n      this.rootPath = rootPath;\n      this.importPath = this.constructor.importPath;\n      // apply property defaults...\n      let p$ = propertyDefaults(this.constructor);\n      if (!p$) {\n        return;\n      }\n      for (let p in p$) {\n        let info = p$[p];\n        if (this._canApplyPropertyDefault(p)) {\n          let value = typeof info.value == 'function' ?\n            info.value.call(this) :\n            info.value;\n          // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determines if a property dfeault can be applied. For example, this\n     * prevents a default from being applied when a property that has no\n     * accessor is overridden by its host before upgrade (e.g. via a binding).\n     * @override\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property default can be applied.\n     */\n    _canApplyPropertyDefault(property) {\n      return !this.hasOwnProperty(property);\n    }\n\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     * @nocollapse\n     */\n    static _processStyleText(cssText, baseURI) {\n      return resolveCss(cssText, baseURI);\n    }\n\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    * @nocollapse\n    */\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? resolveUrl(importPath) : '';\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\n        processElementStyles(this, template, is, baseURI);\n        this.prototype._bindTemplate(template);\n      }\n    }\n\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));\n      }\n      super.connectedCallback();\n    }\n\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n      super.ready();\n    }\n\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));\n      }\n      // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n      super._readyClients();\n    }\n\n\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n    _attachDom(dom) {\n      const n = wrap(this);\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({mode: 'open', shadyUpgradeFragment: dom});\n            n.shadowRoot.appendChild(dom);\n            // When `adoptedStyleSheets` is supported a stylesheet is made\n            // available on the element constructor.\n            if (this.constructor._styleSheet) {\n              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];\n            }\n          }\n          if (syncInitialRender && window.ShadyDOM) {\n            window.ShadyDOM.flushInitial(n.shadowRoot);\n          }\n          return n.shadowRoot;\n        }\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' +\n          // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' +\n        'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);\n      }\n    }\n\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = resolveUrl(this.importPath);\n      }\n      return resolveUrl(url, base);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._parseTemplateContent.call(\n        this, template, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (legacyWarnings && !(prop in this._properties) &&\n          // Methods used in templates with no dependencies (or only literal\n          // dependencies) become accessors with template effects; ignore these\n          !(effect.info.part.signature && effect.info.part.signature.static) &&\n          // Warnings for bindings added to nested templates are handled by\n          // templatizer so ignore both the host-to-template bindings\n          // (`hostProp`) and TemplateInstance-to-child bindings\n          // (`nestedTemplate`)\n          !effect.info.part.hostProp && !templateInfo.nestedTemplate) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` +\n          `attribute will not be observed.`);\n      }\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._addTemplatePropertyEffect.call(\n        this, templateInfo, prop, effect);\n    }\n\n  }\n\n  return PolymerElement;\n});\n\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\nexport const updateStyles = function(props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}