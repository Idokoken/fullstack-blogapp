{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js'; // 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\n\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\n\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n\n  return placeholderBug;\n}\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\n\n\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n\n    while (t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo); // unwind the stack, returning the indexed node at each level\n\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n} // construct `$` map (from id annotations)\n\n\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n} // install event listeners (from event annotations)\n\n\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n} // push configuration references at configure time\n\n\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n\n  let handler = function (e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n\n  return handler;\n}\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\n\n\nexport const TemplateStamp = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let\n        /** ? */\n        templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace'); // TODO(rictic): fix typing\n\n        this._parseTemplateContent(template, templateInfo,\n        /** @type {?} */\n        {\n          parent: null\n        });\n      }\n\n      return template._templateInfo;\n    }\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n\n\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element =\n      /** @type {!HTMLTemplateElement} */\n      node;\n\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n\n      fixPlaceholder(element);\n\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      } // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n\n\n      return noted || nodeInfo.noted;\n    }\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n\n\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n\n      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        } // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n\n\n        next = node.nextSibling;\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          let\n          /** Node */\n          n = next;\n\n          while (n && n.nodeType === Node.TEXT_NODE) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          } // optionally strip whitespace\n\n\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n\n        let childInfo =\n        /** @type {!NodeInfo} */\n        {\n          parentIndex,\n          parentInfo: nodeInfo\n        };\n\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        } // Increment if not removed\n\n\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element =\n      /** @type {!HTMLTemplateElement} */\n      node;\n\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n\n      let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n\n      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n\n      return noted;\n    }\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n\n\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      } // static id\n      else if (name === 'id') {\n          nodeInfo.id = value;\n          return true;\n        }\n\n      return false;\n    }\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n\n\n    static _contentForTemplate(template) {\n      let templateInfo =\n      /** @type {HTMLTemplateElementWithInfo} */\n      template._templateInfo;\n      return templateInfo && templateInfo.content || template.content;\n    }\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n\n\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      } // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n\n\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom =\n      /** @type {DocumentFragment} */\n      document.importNode(content, true); // NOTE: ShadyDom optimization indicating there is an insertion point\n\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n\n      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n\n      dom =\n      /** @type {!StampedTemplate} */\n      dom; // eslint-disable-line no-self-assign\n\n      return dom;\n    }\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n\n\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n\n      this._addEventListenerToNode(node, eventName, handler);\n\n      return handler;\n    }\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n\n\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n\n\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n});","map":{"version":3,"sources":["C:/Users/Idokoken/Desktop/ict_exercise/projects/fullstack/fullstack-blogapp/frontend/node_modules/@polymer/polymer/lib/mixins/template-stamp.js"],"names":["dedupingMixin","templateExtensions","placeholderBugDetect","placeholderBug","hasPlaceholderBug","t","document","createElement","placeholder","textContent","fixPlaceholder","node","localName","wrapTemplateExtension","is","getAttribute","removeAttribute","ownerDocument","parentNode","replaceChild","appendChild","attributes","length","setAttribute","name","value","findTemplateNode","root","nodeInfo","parent","parentInfo","n","firstChild","i","nextSibling","parentIndex","applyIdToMap","inst","map","id","applyEventListener","events","j","e$","e","_addMethodEventListenerToNode","applyTemplateInfo","parentTemplateInfo","templateInfo","_templateInfo","_parentTemplateInfo","createNodeEventHandler","context","eventName","methodName","_methodHost","handler","detail","console","warn","TemplateStamp","superClass","_parseTemplate","template","outerTemplateInfo","nodeInfoList","nestedTemplate","Boolean","stripWhiteSpace","hasAttribute","_parseTemplateContent","_parseTemplateNode","content","noted","element","_parseTemplateNestedTemplate","hasInsertionPoint","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","next","nodeType","Node","TEXT_NODE","removeChild","trim","childInfo","infoIndex","push","createDocumentFragment","attrs","Array","from","a","_parseTemplateNodeAttribute","slice","_contentForTemplate","_stampTemplate","window","HTMLTemplateElement","decorate","constructor","dom","importNode","__noInsertionPoint","nodes","nodeList","$","l","info","_addEventListenerToNode","addEventListener","_removeEventListenerFromNode","removeEventListener"],"mappings":"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","sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\n\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\n\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder\n        && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while(t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport const TemplateStamp = dedupingMixin(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */ templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace =\n          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n          template.hasAttribute('strip-whitespace');\n         // TODO(rictic): fix typing\n         this._parseTemplateContent(\n             template, templateInfo, /** @type {?} */ ({parent: null}));\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */ n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo =\n            /** @type {!NodeInfo} */ ({parentIndex, parentInfo: nodeInfo});\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content =\n          element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\n      return (templateInfo && templateInfo.content) || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content &&\n          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n\n});\n"]},"metadata":{},"sourceType":"module"}